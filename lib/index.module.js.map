{"version":3,"file":"index.module.js","sources":["../src/util.ts","../src/Digest.ts","../src/signers/ES256KSigner.ts","../src/signers/SimpleSigner.ts","../src/signers/EllipticSigner.ts","../src/signers/EdDSASigner.ts","../src/signers/NaclSigner.ts","../src/signers/ES256Signer.ts","../src/signers/ES256HSMSigner.ts","../src/SignerAlgorithm.ts","../src/blockchains/bip122.ts","../src/blockchains/cosmos.ts","../src/blockchains/index.ts","../src/VerifierAlgorithm.ts","../src/Errors.ts","../src/ConditionalAlgorithm.ts","../src/JWT.ts","../src/encryption/JWE.ts","../src/encryption/xc20pDir.ts","../src/encryption/X25519-ECDH-ES.ts","../src/encryption/X25519-ECDH-1PU.ts","../src/encryption/ECDH.ts","../src/encryption/createEncrypter.ts","../src/encryption/xc20pEncryption.ts"],"sourcesContent":["import { concat, fromString, toString } from 'uint8arrays'\nimport { x25519 } from '@noble/curves/ed25519'\nimport type { EphemeralKeyPair } from './encryption/types.js'\nimport { varint } from 'multiformats'\nimport { BaseName, decode, encode } from 'multibase'\nimport type { VerificationMethod } from 'did-resolver'\nimport { secp256k1 } from '@noble/curves/secp256k1'\nimport { p256 } from '@noble/curves/p256'\n\nconst u8a = { toString, fromString, concat }\n\n/**\n * @deprecated Signers will be expected to return base64url `string` signatures.\n */\nexport interface EcdsaSignature {\n  r: string\n  s: string\n  recoveryParam?: number\n}\n\n/**\n * @deprecated Signers will be expected to return base64url `string` signatures.\n */\nexport type ECDSASignature = {\n  compact: Uint8Array\n  recovery?: number\n}\n\nexport type JsonWebKey = {\n  crv: string\n  kty: string\n  x?: string\n  y?: string\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [key: string]: any\n}\n\nexport function bytesToBase64url(b: Uint8Array): string {\n  return u8a.toString(b, 'base64url')\n}\n\nexport function base64ToBytes(s: string): Uint8Array {\n  const inputBase64Url = s.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '')\n  return u8a.fromString(inputBase64Url, 'base64url')\n}\n\nexport function bytesToBase64(b: Uint8Array): string {\n  return u8a.toString(b, 'base64pad')\n}\n\nexport function base58ToBytes(s: string): Uint8Array {\n  return u8a.fromString(s, 'base58btc')\n}\n\nexport function bytesToBase58(b: Uint8Array): string {\n  return u8a.toString(b, 'base58btc')\n}\n\nexport type KNOWN_JWA = 'ES256' | 'ES256K' | 'ES256K-R' | 'Ed25519' | 'EdDSA'\n\nexport type KNOWN_VERIFICATION_METHOD =\n  | 'JsonWebKey2020'\n  | 'Multikey'\n  | 'Secp256k1SignatureVerificationKey2018' // deprecated in favor of EcdsaSecp256k1VerificationKey2019\n  | 'Secp256k1VerificationKey2018' // deprecated in favor of EcdsaSecp256k1VerificationKey2019\n  | 'EcdsaSecp256k1VerificationKey2019' // ES256K / ES256K-R\n  | 'EcdsaPublicKeySecp256k1' // deprecated in favor of EcdsaSecp256k1VerificationKey2019\n  | 'EcdsaSecp256k1RecoveryMethod2020' // ES256K-R (ES256K also supported with 1 less bit of security)\n  | 'EcdsaSecp256r1VerificationKey2019' // ES256 / P-256\n  | 'Ed25519VerificationKey2018'\n  | 'Ed25519VerificationKey2020'\n  | 'ED25519SignatureVerification' // deprecated\n  | 'ConditionalProof2022'\n  | 'X25519KeyAgreementKey2019' // deprecated\n  | 'X25519KeyAgreementKey2020'\n\nexport type KNOWN_KEY_TYPE = 'Secp256k1' | 'Ed25519' | 'X25519' | 'Bls12381G1' | 'Bls12381G2' | 'P-256'\n\nexport type PublicKeyTypes = Record<KNOWN_JWA, KNOWN_VERIFICATION_METHOD[]>\n\nexport const SUPPORTED_PUBLIC_KEY_TYPES: PublicKeyTypes = {\n  ES256: ['JsonWebKey2020', 'Multikey', 'EcdsaSecp256r1VerificationKey2019'],\n  ES256K: [\n    'EcdsaSecp256k1VerificationKey2019',\n    /**\n     * Equivalent to EcdsaSecp256k1VerificationKey2019 when key is an ethereumAddress\n     */\n    'EcdsaSecp256k1RecoveryMethod2020',\n    /**\n     * @deprecated, supported for backward compatibility. Equivalent to EcdsaSecp256k1VerificationKey2019 when key is\n     *   not an ethereumAddress\n     */\n    'Secp256k1VerificationKey2018',\n    /**\n     * @deprecated, supported for backward compatibility. Equivalent to EcdsaSecp256k1VerificationKey2019 when key is\n     *   not an ethereumAddress\n     */\n    'Secp256k1SignatureVerificationKey2018',\n    /**\n     * @deprecated, supported for backward compatibility. Equivalent to EcdsaSecp256k1VerificationKey2019 when key is\n     *   not an ethereumAddress\n     */\n    'EcdsaPublicKeySecp256k1',\n    /**\n     *  TODO - support R1 key as well\n     *   'ConditionalProof2022',\n     */\n    'JsonWebKey2020',\n    'Multikey',\n  ],\n  'ES256K-R': [\n    'EcdsaSecp256k1VerificationKey2019',\n    /**\n     * Equivalent to EcdsaSecp256k1VerificationKey2019 when key is an ethereumAddress\n     */\n    'EcdsaSecp256k1RecoveryMethod2020',\n    /**\n     * @deprecated, supported for backward compatibility. Equivalent to EcdsaSecp256k1VerificationKey2019 when key is\n     *   not an ethereumAddress\n     */\n    'Secp256k1VerificationKey2018',\n    /**\n     * @deprecated, supported for backward compatibility. Equivalent to EcdsaSecp256k1VerificationKey2019 when key is\n     *   not an ethereumAddress\n     */\n    'Secp256k1SignatureVerificationKey2018',\n    /**\n     * @deprecated, supported for backward compatibility. Equivalent to EcdsaSecp256k1VerificationKey2019 when key is\n     *   not an ethereumAddress\n     */\n    'EcdsaPublicKeySecp256k1',\n    'ConditionalProof2022',\n    'JsonWebKey2020',\n    'Multikey',\n  ],\n  Ed25519: [\n    'ED25519SignatureVerification',\n    'Ed25519VerificationKey2018',\n    'Ed25519VerificationKey2020',\n    'JsonWebKey2020',\n    'Multikey',\n  ],\n  EdDSA: [\n    'ED25519SignatureVerification',\n    'Ed25519VerificationKey2018',\n    'Ed25519VerificationKey2020',\n    'JsonWebKey2020',\n    'Multikey',\n  ],\n}\n\nexport const VM_TO_KEY_TYPE: Record<KNOWN_VERIFICATION_METHOD, KNOWN_KEY_TYPE | undefined> = {\n  Secp256k1SignatureVerificationKey2018: 'Secp256k1',\n  Secp256k1VerificationKey2018: 'Secp256k1',\n  EcdsaSecp256k1VerificationKey2019: 'Secp256k1',\n  EcdsaPublicKeySecp256k1: 'Secp256k1',\n  EcdsaSecp256k1RecoveryMethod2020: 'Secp256k1',\n  EcdsaSecp256r1VerificationKey2019: 'P-256',\n  Ed25519VerificationKey2018: 'Ed25519',\n  Ed25519VerificationKey2020: 'Ed25519',\n  ED25519SignatureVerification: 'Ed25519',\n  X25519KeyAgreementKey2019: 'X25519',\n  X25519KeyAgreementKey2020: 'X25519',\n  ConditionalProof2022: undefined,\n  JsonWebKey2020: undefined, // key type must be specified in the JWK\n  Multikey: undefined, // key type must be extracted from the multicodec\n}\n\nexport type KNOWN_CODECS =\n  | 'ed25519-pub'\n  | 'x25519-pub'\n  | 'secp256k1-pub'\n  | 'bls12_381-g1-pub'\n  | 'bls12_381-g2-pub'\n  | 'p256-pub'\n\n// this is from the multicodec table https://github.com/multiformats/multicodec/blob/master/table.csv\nexport const supportedCodecs: Record<KNOWN_CODECS, number> = {\n  'ed25519-pub': 0xed,\n  'x25519-pub': 0xec,\n  'secp256k1-pub': 0xe7,\n  'bls12_381-g1-pub': 0xea,\n  'bls12_381-g2-pub': 0xeb,\n  'p256-pub': 0x1200,\n}\n\nexport const CODEC_TO_KEY_TYPE: Record<KNOWN_CODECS, KNOWN_KEY_TYPE> = {\n  'bls12_381-g1-pub': 'Bls12381G1',\n  'bls12_381-g2-pub': 'Bls12381G2',\n  'ed25519-pub': 'Ed25519',\n  'p256-pub': 'P-256',\n  'secp256k1-pub': 'Secp256k1',\n  'x25519-pub': 'X25519',\n}\n\n/**\n * Extracts the raw byte representation of a public key from a VerificationMethod along with an inferred key type\n * @param pk a VerificationMethod entry from a DIDDocument\n * @return an object containing the `keyBytes` of the public key and an inferred `keyType`\n */\nexport function extractPublicKeyBytes(pk: VerificationMethod): { keyBytes: Uint8Array; keyType?: KNOWN_KEY_TYPE } {\n  if (pk.publicKeyBase58) {\n    return {\n      keyBytes: base58ToBytes(pk.publicKeyBase58),\n      keyType: VM_TO_KEY_TYPE[pk.type as KNOWN_VERIFICATION_METHOD],\n    }\n  } else if (pk.publicKeyBase64) {\n    return {\n      keyBytes: base64ToBytes(pk.publicKeyBase64),\n      keyType: VM_TO_KEY_TYPE[pk.type as KNOWN_VERIFICATION_METHOD],\n    }\n  } else if (pk.publicKeyHex) {\n    return { keyBytes: hexToBytes(pk.publicKeyHex), keyType: VM_TO_KEY_TYPE[pk.type as KNOWN_VERIFICATION_METHOD] }\n  } else if (pk.publicKeyJwk && pk.publicKeyJwk.crv === 'secp256k1' && pk.publicKeyJwk.x && pk.publicKeyJwk.y) {\n    return {\n      keyBytes: secp256k1.ProjectivePoint.fromAffine({\n        x: bytesToBigInt(base64ToBytes(pk.publicKeyJwk.x)),\n        y: bytesToBigInt(base64ToBytes(pk.publicKeyJwk.y)),\n      }).toRawBytes(false),\n      keyType: 'Secp256k1',\n    }\n  } else if (pk.publicKeyJwk && pk.publicKeyJwk.crv === 'P-256' && pk.publicKeyJwk.x && pk.publicKeyJwk.y) {\n    return {\n      keyBytes: p256.ProjectivePoint.fromAffine({\n        x: bytesToBigInt(base64ToBytes(pk.publicKeyJwk.x)),\n        y: bytesToBigInt(base64ToBytes(pk.publicKeyJwk.y)),\n      }).toRawBytes(false),\n      keyType: 'P-256',\n    }\n  } else if (\n    pk.publicKeyJwk &&\n    pk.publicKeyJwk.kty === 'OKP' &&\n    ['Ed25519', 'X25519'].includes(pk.publicKeyJwk.crv ?? '') &&\n    pk.publicKeyJwk.x\n  ) {\n    return { keyBytes: base64ToBytes(pk.publicKeyJwk.x), keyType: pk.publicKeyJwk.crv as KNOWN_KEY_TYPE }\n  } else if (pk.publicKeyMultibase) {\n    const { keyBytes, keyType } = multibaseToBytes(pk.publicKeyMultibase)\n    return { keyBytes, keyType: keyType ?? VM_TO_KEY_TYPE[pk.type as KNOWN_VERIFICATION_METHOD] }\n  }\n  return { keyBytes: new Uint8Array() }\n}\n\n/**\n * Encodes the given byte array to a multibase string (defaulting to base58btc).\n * If a codec is provided, the corresponding multicodec prefix will be added.\n *\n * @param b - the Uint8Array to be encoded\n * @param base - the base to use for encoding (defaults to base58btc)\n * @param codec - the codec to use for encoding (defaults to no codec)\n *\n * @returns the multibase encoded string\n *\n * @public\n */\nexport function bytesToMultibase(\n  b: Uint8Array,\n  base: BaseName = 'base58btc',\n  codec?: keyof typeof supportedCodecs | number\n): string {\n  if (!codec) {\n    return u8a.toString(encode(base, b), 'utf-8')\n  } else {\n    const codecCode = typeof codec === 'string' ? supportedCodecs[codec] : codec\n    const prefixLength = varint.encodingLength(codecCode)\n    const multicodecEncoding = new Uint8Array(prefixLength + b.length)\n    varint.encodeTo(codecCode, multicodecEncoding) // set prefix\n    multicodecEncoding.set(b, prefixLength) // add the original bytes\n    return u8a.toString(encode(base, multicodecEncoding), 'utf-8')\n  }\n}\n\n/**\n * Converts a multibase string to the Uint8Array it represents.\n * This method will assume the byte array that is multibase encoded is a multicodec and will attempt to decode it.\n *\n * @param s - the string to be converted\n *\n * @throws if the string is not formatted correctly.\n *\n * @public\n */\nexport function multibaseToBytes(s: string): { keyBytes: Uint8Array; keyType?: KNOWN_KEY_TYPE } {\n  const bytes = decode(s)\n\n  // look for known key lengths first\n  // Ed25519/X25519, secp256k1/P256 compressed or not, BLS12-381 G1/G2 compressed\n  if ([32, 33, 48, 64, 65, 96].includes(bytes.length)) {\n    return { keyBytes: bytes }\n  }\n\n  // then assume multicodec, otherwise return the bytes\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const [codec, length] = varint.decode(bytes)\n    const possibleCodec: string | undefined =\n      Object.entries(supportedCodecs).filter(([, code]) => code === codec)?.[0][0] ?? ''\n    return { keyBytes: bytes.slice(length), keyType: CODEC_TO_KEY_TYPE[possibleCodec as KNOWN_CODECS] }\n  } catch (e) {\n    // not a multicodec, return the bytes\n    return { keyBytes: bytes }\n  }\n}\n\nexport function hexToBytes(s: string, minLength?: number): Uint8Array {\n  let input = s.startsWith('0x') ? s.substring(2) : s\n\n  if (input.length % 2 !== 0) {\n    input = `0${input}`\n  }\n\n  if (minLength) {\n    const paddedLength = Math.max(input.length, minLength * 2)\n    input = input.padStart(paddedLength, '00')\n  }\n\n  return u8a.fromString(input.toLowerCase(), 'base16')\n}\n\nexport function encodeBase64url(s: string): string {\n  return bytesToBase64url(u8a.fromString(s))\n}\n\nexport function decodeBase64url(s: string): string {\n  return u8a.toString(base64ToBytes(s))\n}\n\nexport function bytesToHex(b: Uint8Array): string {\n  return u8a.toString(b, 'base16')\n}\n\nexport function bytesToBigInt(b: Uint8Array): bigint {\n  return BigInt(`0x` + u8a.toString(b, 'base16'))\n}\n\nexport function bigintToBytes(n: bigint, minLength?: number): Uint8Array {\n  return hexToBytes(n.toString(16), minLength)\n}\n\nexport function stringToBytes(s: string): Uint8Array {\n  return u8a.fromString(s, 'utf-8')\n}\n\nexport function toJose({ r, s, recoveryParam }: EcdsaSignature, recoverable?: boolean): string {\n  const jose = new Uint8Array(recoverable ? 65 : 64)\n  jose.set(u8a.fromString(r, 'base16'), 0)\n  jose.set(u8a.fromString(s, 'base16'), 32)\n  if (recoverable) {\n    if (typeof recoveryParam === 'undefined') {\n      throw new Error('Signer did not return a recoveryParam')\n    }\n    jose[64] = <number>recoveryParam\n  }\n  return bytesToBase64url(jose)\n}\n\nexport function fromJose(signature: string): { r: string; s: string; recoveryParam?: number } {\n  const signatureBytes: Uint8Array = base64ToBytes(signature)\n  if (signatureBytes.length < 64 || signatureBytes.length > 65) {\n    throw new TypeError(`Wrong size for signature. Expected 64 or 65 bytes, but got ${signatureBytes.length}`)\n  }\n  const r = bytesToHex(signatureBytes.slice(0, 32))\n  const s = bytesToHex(signatureBytes.slice(32, 64))\n  const recoveryParam = signatureBytes.length === 65 ? signatureBytes[64] : undefined\n  return { r, s, recoveryParam }\n}\n\nexport function toSealed(ciphertext: string, tag?: string): Uint8Array {\n  return u8a.concat([base64ToBytes(ciphertext), tag ? base64ToBytes(tag) : new Uint8Array(0)])\n}\n\nexport function leftpad(data: string, size = 64): string {\n  if (data.length === size) return data\n  return '0'.repeat(size - data.length) + data\n}\n\n/**\n * Generate random x25519 key pair.\n */\nexport function generateKeyPair(): { secretKey: Uint8Array; publicKey: Uint8Array } {\n  const secretKey = x25519.utils.randomPrivateKey()\n  const publicKey = x25519.getPublicKey(secretKey)\n  return {\n    secretKey: secretKey,\n    publicKey: publicKey,\n  }\n}\n\n/**\n * Generate private-public x25519 key pair from `seed`.\n */\nexport function generateKeyPairFromSeed(seed: Uint8Array): { secretKey: Uint8Array; publicKey: Uint8Array } {\n  if (seed.length !== 32) {\n    throw new Error(`x25519: seed must be ${32} bytes`)\n  }\n  return {\n    publicKey: x25519.getPublicKey(seed),\n    secretKey: seed,\n  }\n}\n\nexport function genX25519EphemeralKeyPair(): EphemeralKeyPair {\n  const epk = generateKeyPair()\n  return {\n    publicKeyJWK: { kty: 'OKP', crv: 'X25519', x: bytesToBase64url(epk.publicKey) },\n    secretKey: epk.secretKey,\n  }\n}\n\n/**\n * Checks if a variable is defined and not null.\n * After this check, typescript sees the variable as defined.\n *\n * @param arg - The input to be verified\n *\n * @returns true if the input variable is defined.\n */\nexport function isDefined<T>(arg: T): arg is Exclude<T, null | undefined> {\n  return arg !== null && typeof arg !== 'undefined'\n}\n","import { sha256 as sha256Hash } from '@noble/hashes/sha256'\nexport { ripemd160 } from '@noble/hashes/ripemd160'\nimport { keccak_256 } from '@noble/hashes/sha3'\nimport { fromString, toString, concat } from 'uint8arrays'\n\nexport function sha256(payload: string | Uint8Array): Uint8Array {\n  const data = typeof payload === 'string' ? fromString(payload) : payload\n  return sha256Hash(data)\n}\n\nexport const keccak = keccak_256\n\nexport function toEthereumAddress(hexPublicKey: string): string {\n  const hashInput = fromString(hexPublicKey.slice(2), 'base16')\n  return `0x${toString(keccak(hashInput).slice(-20), 'base16')}`\n}\n\nfunction writeUint32BE(value: number, array = new Uint8Array(4)): Uint8Array {\n  const encoded = fromString(value.toString(), 'base10')\n  array.set(encoded, 4 - encoded.length)\n  return array\n}\n\nconst lengthAndInput = (input: Uint8Array): Uint8Array => concat([writeUint32BE(input.length), input])\n\n// This implementation of concatKDF was inspired by these two implementations:\n// https://github.com/digitalbazaar/minimal-cipher/blob/master/algorithms/ecdhkdf.js\n// https://github.com/panva/jose/blob/master/lib/jwa/ecdh/derive.js\nexport function concatKDF(\n  secret: Uint8Array,\n  keyLen: number,\n  alg: string,\n  producerInfo?: Uint8Array,\n  consumerInfo?: Uint8Array\n): Uint8Array {\n  if (keyLen !== 256) throw new Error(`Unsupported key length: ${keyLen}`)\n  const value = concat([\n    lengthAndInput(fromString(alg)),\n    lengthAndInput(typeof producerInfo === 'undefined' ? new Uint8Array(0) : producerInfo), // apu\n    lengthAndInput(typeof consumerInfo === 'undefined' ? new Uint8Array(0) : consumerInfo), // apv\n    writeUint32BE(keyLen),\n  ])\n\n  // since our key lenght is 256 we only have to do one round\n  const roundNumber = 1\n  return sha256(concat([writeUint32BE(roundNumber), secret, value]))\n}\n","import { leftpad, toJose } from '../util.js'\nimport { Signer } from '../JWT.js'\nimport { sha256 } from '../Digest.js'\nimport { secp256k1 } from '@noble/curves/secp256k1'\n\n/**\n *  Creates a configured signer function for signing data using the ES256K (secp256k1 + sha256) algorithm.\n *\n *  The signing function itself takes the data as a `Uint8Array` or `string` and returns a `base64Url`-encoded signature\n *\n *  @example\n *  ```typescript\n *  const sign: Signer = ES256KSigner(process.env.PRIVATE_KEY)\n *  const signature: string = await sign(data)\n *  ```\n *\n *  @param    {String}    privateKey   a private key as `Uint8Array`\n *  @param    {Boolean}   recoverable  an optional flag to add the recovery param to the generated signatures\n *  @return   {Function}               a configured signer function `(data: string | Uint8Array): Promise<string>`\n */\nexport function ES256KSigner(privateKey: Uint8Array, recoverable = false): Signer {\n  const privateKeyBytes: Uint8Array = privateKey\n  if (privateKeyBytes.length !== 32) {\n    throw new Error(`bad_key: Invalid private key format. Expecting 32 bytes, but got ${privateKeyBytes.length}`)\n  }\n\n  return async (data: string | Uint8Array): Promise<string> => {\n    const signature = secp256k1.sign(sha256(data), privateKeyBytes)\n    return toJose(\n      {\n        r: leftpad(signature.r.toString(16)),\n        s: leftpad(signature.s.toString(16)),\n        recoveryParam: signature.recovery,\n      },\n      recoverable\n    )\n  }\n}\n","import { fromJose, hexToBytes } from '../util.js'\nimport type { Signer } from '../JWT.js'\nimport { ES256KSigner } from './ES256KSigner.js'\n\n/**\n * @deprecated Please use ES256KSigner\n *  The SimpleSigner returns a configured function for signing data.\n *\n *  @example\n *  const signer = SimpleSigner(process.env.PRIVATE_KEY)\n *  signer(data, (err, signature) => {\n *    ...\n *  })\n *\n *  @param    {String}         hexPrivateKey    a hex encoded private key\n *  @return   {Function}                     a configured signer function\n */\nfunction SimpleSigner(hexPrivateKey: string): Signer {\n  const signer = ES256KSigner(hexToBytes(hexPrivateKey), true)\n  return async (data) => {\n    const signature = (await signer(data)) as string\n    return fromJose(signature)\n  }\n}\n\nexport default SimpleSigner\n","import type { Signer } from '../JWT.js'\nimport { hexToBytes } from '../util.js'\nimport { ES256KSigner } from './ES256KSigner.js'\n\n/**\n * @deprecated Please use ES256KSigner\n *  The EllipticSigner returns a configured function for signing data.\n *\n *  @example\n *  ```typescript\n *  const signer = EllipticSigner(process.env.PRIVATE_KEY)\n *  signer(data).then( (signature: string) => {\n *    ...\n *  })\n *  ```\n *\n *  @param    {String}         hexPrivateKey    a hex encoded private key\n *  @return   {Function}                        a configured signer function\n */\nfunction EllipticSigner(hexPrivateKey: string): Signer {\n  return ES256KSigner(hexToBytes(hexPrivateKey))\n}\n\nexport default EllipticSigner\n","import { ed25519 } from '@noble/curves/ed25519'\nimport type { Signer } from '../JWT.js'\nimport { bytesToBase64url, stringToBytes } from '../util.js'\n\n/**\n *  Creates a configured signer function for signing data using the EdDSA (Ed25519) algorithm.\n *\n *  The private key is expected to be a `Uint8Array` of 32 bytes, but for compatibility 64 bytes are also acceptable.\n * Users of `@stablelib/ed25519` or `tweetnacl` will be able to use the 64 byte secret keys that library generates.\n * These libraries precompute the public key and append it as the last 32 bytes of the secretKey, to speed up later\n * signing operations.\n *\n *  The signing function itself takes the data as a `Uint8Array` or utf8 `string` and returns a `base64Url`-encoded\n * signature\n *\n *  @example\n *  ```typescript\n *  const sign: Signer = EdDSASigner(process.env.PRIVATE_KEY)\n *  const signature: string = await sign(data)\n *  ```\n *\n *  @param    {String}    secretKey   a 32 or 64 byte secret key as `Uint8Array`\n *  @return   {Function}              a configured signer function `(data: string | Uint8Array): Promise<string>`\n */\nexport function EdDSASigner(secretKey: Uint8Array): Signer {\n  const privateKeyBytes: Uint8Array = secretKey\n  if (![32, 64].includes(privateKeyBytes.length)) {\n    throw new Error(`bad_key: Invalid private key format. Expecting 32 or 64 bytes, but got ${privateKeyBytes.length}`)\n  }\n  return async (data: string | Uint8Array): Promise<string> => {\n    const dataBytes: Uint8Array = typeof data === 'string' ? stringToBytes(data) : data\n    const signature = ed25519.sign(dataBytes, privateKeyBytes.slice(0, 32))\n    return bytesToBase64url(signature)\n  }\n}\n","import { EdDSASigner as EdDSASigner } from './EdDSASigner.js'\nimport type { Signer } from '../JWT.js'\nimport { base64ToBytes } from '../util.js'\n\n/**\n * @deprecated Please use EdDSASigner\n *\n *  The NaclSigner returns a configured function for signing data using the Ed25519 algorithm.\n *\n *  The signing function itself takes the data as a `string` or `Uint8Array` parameter and returns a\n *   `base64Url`-encoded signature.\n *\n *  @example\n *  const signer = NaclSigner(process.env.PRIVATE_KEY)\n *  const data: string = '...'\n *  signer(data).then( (signature: string) => {\n *    ...\n *  })\n *\n *  @param    {String}   base64PrivateKey    a 64 byte base64 encoded private key\n *  @return   {Function}                     a configured signer function\n */\n\nfunction NaclSigner(base64PrivateKey: string): Signer {\n  return EdDSASigner(base64ToBytes(base64PrivateKey))\n}\n\nexport default NaclSigner\n","import { leftpad, toJose } from '../util.js'\nimport { Signer } from '../JWT.js'\nimport { sha256 } from '../Digest.js'\nimport { p256 } from '@noble/curves/p256'\n\n/**\n *  Creates a configured signer function for signing data using the ES256 (secp256r1 + sha256) algorithm.\n *\n *  The signing function itself takes the data as a `Uint8Array` or `string` and returns a `base64Url`-encoded signature\n *\n *  @example\n *  ```typescript\n *  const sign: Signer = ES256Signer(process.env.PRIVATE_KEY)\n *  const signature: string = await sign(data)\n *  ```\n *\n *  @param    {String}    privateKey   a private key as `Uint8Array`\n *  @return   {Function}               a configured signer function `(data: string | Uint8Array): Promise<string>`\n */\nexport function ES256Signer(privateKey: Uint8Array): Signer {\n  if (privateKey.length !== 32) {\n    throw new Error(`bad_key: Invalid private key format. Expecting 32 bytes, but got ${privateKey.length}`)\n  }\n  return async (data: string | Uint8Array): Promise<string> => {\n    const signature = p256.sign(sha256(data), privateKey)\n    return toJose({\n      r: leftpad(signature.r.toString(16)),\n      s: leftpad(signature.s.toString(16)),\n    })\n  }\n}\n","import { leftpad, toJose } from '../util.js'\nimport { Signer } from '../JWT.js'\nimport { sha256 } from '../Digest.js'\n\n/**\n *  Creates a configured signer function for signing data using the ES256 (secp256r1 + sha256) algorithm.\n *\n *  The signing function itself takes the data as a `Uint8Array` or `string` and returns a `base64Url`-encoded signature\n *\n *  @example\n *  ```typescript\n *  const sign: Signer = ES256Signer(process.env.PUF_HSM_REMOTE_URL)\n *  const signature: string = await sign(data)\n *  ```\n *\n *  @param    {String}    PUF_HSM_REMOTE_URL   a puf hsm url as `Uint8Array`\n *  @return   {Function}               a configured signer function `(data: string | Uint8Array): Promise<string>`\n */\nexport function ES256HSMSigner(pufHsmRemoteUrl: string): Signer {\n  return async (data: string | Uint8Array): Promise<string> => {\n    try {\n      const response = await fetch(pufHsmRemoteUrl+'/pufs_p256_sign_js', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ content: sha256(data) }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const signature = await response.text()\n      return toJose({\n        r: leftpad(JSON.parse(signature).r.toString(16)),\n        s: leftpad(JSON.parse(signature).s.toString(16)),\n      })\n\n    } catch (error) {\n      console.error(\"Error summarizing text:\", error);\n      throw error; // Handle the error appropriately\n    }\n\n\n  }\n}\n","import type { Signer, SignerAlgorithm } from './JWT.js'\nimport { type EcdsaSignature, fromJose, toJose } from './util.js'\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction instanceOfEcdsaSignature(object: any): object is EcdsaSignature {\n  return typeof object === 'object' && 'r' in object && 's' in object\n}\n\nexport function ES256SignerAlg(): SignerAlgorithm {\n  return async function sign(payload: string, signer: Signer): Promise<string> {\n    const signature: EcdsaSignature | string = await signer(payload)\n    if (instanceOfEcdsaSignature(signature)) {\n      return toJose(signature)\n    } else {\n      return signature\n    }\n  }\n}\n\nexport function ES256KSignerAlg(recoverable?: boolean): SignerAlgorithm {\n  return async function sign(payload: string, signer: Signer): Promise<string> {\n    const signature: EcdsaSignature | string = await signer(payload)\n    if (instanceOfEcdsaSignature(signature)) {\n      return toJose(signature, recoverable)\n    } else {\n      if (recoverable && typeof fromJose(signature).recoveryParam === 'undefined') {\n        throw new Error(`not_supported: ES256K-R not supported when signer doesn't provide a recovery param`)\n      }\n      return signature\n    }\n  }\n}\n\nexport function Ed25519SignerAlg(): SignerAlgorithm {\n  return async function sign(payload: string, signer: Signer): Promise<string> {\n    const signature: EcdsaSignature | string = await signer(payload)\n    if (!instanceOfEcdsaSignature(signature)) {\n      return signature\n    } else {\n      throw new Error('invalid_config: expected a signer function that returns a string instead of signature object')\n    }\n  }\n}\n\ninterface SignerAlgorithms {\n  [alg: string]: SignerAlgorithm\n}\n\nconst algorithms: SignerAlgorithms = {\n  ES256: ES256SignerAlg(),\n  ES256K: ES256KSignerAlg(),\n  // This is a non-standard algorithm but retained for backwards compatibility\n  // see https://github.com/decentralized-identity/did-jwt/issues/146\n  'ES256K-R': ES256KSignerAlg(true),\n  // This is actually incorrect but retained for backwards compatibility\n  // see https://github.com/decentralized-identity/did-jwt/issues/130\n  Ed25519: Ed25519SignerAlg(),\n  EdDSA: Ed25519SignerAlg(),\n}\n\nfunction SignerAlg(alg: string): SignerAlgorithm {\n  const impl: SignerAlgorithm = algorithms[alg]\n  if (!impl) throw new Error(`not_supported: Unsupported algorithm ${alg}`)\n  return impl\n}\n\nexport default SignerAlg\n","import { base58ToBytes, bytesToBase58, bytesToHex, hexToBytes } from '../util.js'\nimport { ripemd160, sha256 } from '../Digest.js'\n\nexport function publicKeyToAddress(publicKey: string, otherAddress: string): string {\n  // Use the same version/prefix byte as the given address.\n  const version = bytesToHex(base58ToBytes(otherAddress).slice(0, 1))\n  const publicKeyBuffer = hexToBytes(publicKey)\n  const publicKeyHash = ripemd160(sha256(publicKeyBuffer))\n  const step1 = version + bytesToHex(publicKeyHash)\n  const step2 = sha256(hexToBytes(step1))\n  const step3 = sha256(step2)\n  const checksum = bytesToHex(step3).substring(0, 8)\n  const step4 = step1 + checksum\n  return bytesToBase58(hexToBytes(step4))\n}\n","import { secp256k1 } from '@noble/curves/secp256k1'\nimport { bech32 } from '@scure/base'\nimport { sha256, ripemd160 } from '../Digest.js'\n\nexport function publicKeyToAddress(publicKey: string, prefix: string): string {\n  const publicKeyBuffer = secp256k1.ProjectivePoint.fromHex(publicKey).toRawBytes()\n  const hash = ripemd160(sha256(publicKeyBuffer))\n  const words = bech32.toWords(hash)\n  return bech32.encode(prefix, words).replace(prefix, '')\n}\n","import { publicKeyToAddress as bip122 } from './bip122.js'\nimport { publicKeyToAddress as cosmos } from './cosmos.js'\nimport { toEthereumAddress } from '../Digest.js'\n\nexport function verifyBlockchainAccountId(publicKey: string, blockchainAccountId: string | undefined): boolean {\n  if (blockchainAccountId) {\n    const chain = blockchainAccountId.split(':')\n    switch (chain[0]) {\n      case 'bip122':\n        chain[chain.length - 1] = bip122(publicKey, chain[chain.length - 1])\n        break\n      case 'cosmos':\n        chain[chain.length - 1] = cosmos(publicKey, chain[1])\n        break\n      case 'eip155':\n        chain[chain.length - 1] = toEthereumAddress(publicKey)\n        break\n      default:\n        return false\n    }\n    return chain.join(':').toLowerCase() === blockchainAccountId.toLowerCase()\n  }\n  return false\n}\n","import { sha256, toEthereumAddress } from './Digest.js'\nimport type { VerificationMethod } from 'did-resolver'\nimport {\n  base64ToBytes,\n  bytesToHex,\n  EcdsaSignature,\n  ECDSASignature,\n  extractPublicKeyBytes,\n  KNOWN_JWA,\n  stringToBytes,\n} from './util.js'\nimport { verifyBlockchainAccountId } from './blockchains/index.js'\nimport { secp256k1 } from '@noble/curves/secp256k1'\nimport { p256, secp256r1 } from '@noble/curves/p256'\nimport { ed25519 } from '@noble/curves/ed25519'\n\n// converts a JOSE signature to it's components\nexport function toSignatureObject(signature: string, recoverable = false): EcdsaSignature {\n  const rawSig: Uint8Array = base64ToBytes(signature)\n  if (rawSig.length !== (recoverable ? 65 : 64)) {\n    throw new Error('wrong signature length')\n  }\n  const r: string = bytesToHex(rawSig.slice(0, 32))\n  const s: string = bytesToHex(rawSig.slice(32, 64))\n  const sigObj: EcdsaSignature = { r, s }\n  if (recoverable) {\n    sigObj.recoveryParam = rawSig[64]\n  }\n  return sigObj\n}\n\nexport function toSignatureObject2(signature: string, recoverable = false): ECDSASignature {\n  const bytes = base64ToBytes(signature)\n  if (bytes.length !== (recoverable ? 65 : 64)) {\n    throw new Error('wrong signature length')\n  }\n  return {\n    compact: bytes.slice(0, 64),\n    recovery: bytes[64],\n  }\n}\n\nexport function verifyES256_Orig(data: string, signature: string, authenticators: VerificationMethod[]): VerificationMethod {\n  const hash = sha256(data)\n  const sig = p256.Signature.fromCompact(toSignatureObject2(signature).compact)\n  const fullPublicKeys = authenticators.filter((a: VerificationMethod) => !a.ethereumAddress && !a.blockchainAccountId)\n\n  const signer: VerificationMethod | undefined = fullPublicKeys.find((pk: VerificationMethod) => {\n    try {\n      const { keyBytes } = extractPublicKeyBytes(pk)\n      return p256.verify(sig, hash, keyBytes)\n    } catch (err) {\n      return false\n    }\n  })\n\n  if (!signer) throw new Error('invalid_signature: Signature invalid for JWT')\n  return signer\n}\n\nexport function verifyES256(data: string, signature: string, authenticators: VerificationMethod[]): VerificationMethod {\n  const signatures: ECDSASignature[] = []\n  if (signature.length > 86) {\n    signatures.push(toSignatureObject2(signature, true))\n  } else {\n    const so = toSignatureObject2(signature, false)\n    signatures.push({ ...so, recovery: 0 })\n    signatures.push({ ...so, recovery: 1 })\n  }\n  const hash = sha256(data)\n  const checkSignatureAgainstSigner = (sigObj: ECDSASignature): VerificationMethod | undefined => {\n    const signature = p256.Signature.fromCompact(sigObj.compact).addRecoveryBit(sigObj.recovery || 0)\n    const recoveredPublicKey = signature.recoverPublicKey(hash)\n    const recoveredAddress = toEthereumAddress(recoveredPublicKey.toHex(false)).toLowerCase()\n    const recoveredPublicKeyHex = recoveredPublicKey.toHex(false)\n    const recoveredCompressedPublicKeyHex = recoveredPublicKey.toHex(true)\n\n    return authenticators.find((a: VerificationMethod) => {\n      const { keyBytes } = extractPublicKeyBytes(a)\n      const keyHex = bytesToHex(keyBytes)\n      return (\n        keyHex === recoveredPublicKeyHex ||\n        keyHex === recoveredCompressedPublicKeyHex ||\n        a.ethereumAddress?.toLowerCase() === recoveredAddress ||\n        a.blockchainAccountId?.split('@eip155')?.[0].toLowerCase() === recoveredAddress || // CAIP-2\n        verifyBlockchainAccountId(recoveredPublicKeyHex, a.blockchainAccountId) // CAIP-10\n      )\n    })\n  }\n\n  // Find first verification method\n  for (const signature of signatures) {\n    const verificationMethod = checkSignatureAgainstSigner(signature)\n    if (verificationMethod) return verificationMethod\n  }\n  // If no one found matching\n  throw new Error('invalid_signature: Signature invalid for JWT')\n}\n\nexport function verifyES256K(\n  data: string,\n  signature: string,\n  authenticators: VerificationMethod[]\n): VerificationMethod {\n  const hash = sha256(data)\n  const signatureNormalized = secp256k1.Signature.fromCompact(base64ToBytes(signature)).normalizeS()\n  const fullPublicKeys = authenticators.filter((a: VerificationMethod) => {\n    return !a.ethereumAddress && !a.blockchainAccountId\n  })\n  const blockchainAddressKeys = authenticators.filter((a: VerificationMethod) => {\n    return a.ethereumAddress || a.blockchainAccountId\n  })\n\n  let signer: VerificationMethod | undefined = fullPublicKeys.find((pk: VerificationMethod) => {\n    try {\n      const { keyBytes } = extractPublicKeyBytes(pk)\n      return secp256k1.verify(signatureNormalized, hash, keyBytes)\n    } catch (err) {\n      return false\n    }\n  })\n\n  if (!signer && blockchainAddressKeys.length > 0) {\n    signer = verifyRecoverableES256K(data, signature, blockchainAddressKeys)\n  }\n\n  if (!signer) throw new Error('invalid_signature: Signature invalid for JWT')\n  return signer\n}\n\nexport function verifyRecoverableES256K(\n  data: string,\n  signature: string,\n  authenticators: VerificationMethod[]\n): VerificationMethod {\n  const signatures: ECDSASignature[] = []\n  if (signature.length > 86) {\n    signatures.push(toSignatureObject2(signature, true))\n  } else {\n    const so = toSignatureObject2(signature, false)\n    signatures.push({ ...so, recovery: 0 })\n    signatures.push({ ...so, recovery: 1 })\n  }\n  const hash = sha256(data)\n\n  const checkSignatureAgainstSigner = (sigObj: ECDSASignature): VerificationMethod | undefined => {\n    const signature = secp256k1.Signature.fromCompact(sigObj.compact).addRecoveryBit(sigObj.recovery || 0)\n    const recoveredPublicKey = signature.recoverPublicKey(hash)\n    const recoveredAddress = toEthereumAddress(recoveredPublicKey.toHex(false)).toLowerCase()\n    const recoveredPublicKeyHex = recoveredPublicKey.toHex(false)\n    const recoveredCompressedPublicKeyHex = recoveredPublicKey.toHex(true)\n\n    return authenticators.find((a: VerificationMethod) => {\n      const { keyBytes } = extractPublicKeyBytes(a)\n      const keyHex = bytesToHex(keyBytes)\n      return (\n        keyHex === recoveredPublicKeyHex ||\n        keyHex === recoveredCompressedPublicKeyHex ||\n        a.ethereumAddress?.toLowerCase() === recoveredAddress ||\n        a.blockchainAccountId?.split('@eip155')?.[0].toLowerCase() === recoveredAddress || // CAIP-2\n        verifyBlockchainAccountId(recoveredPublicKeyHex, a.blockchainAccountId) // CAIP-10\n      )\n    })\n  }\n\n  // Find first verification method\n  for (const signature of signatures) {\n    const verificationMethod = checkSignatureAgainstSigner(signature)\n    if (verificationMethod) return verificationMethod\n  }\n  // If no one found matching\n  throw new Error('invalid_signature: Signature invalid for JWT')\n}\n\nexport function verifyEd25519(\n  data: string,\n  signature: string,\n  authenticators: VerificationMethod[]\n): VerificationMethod {\n  const clear = stringToBytes(data)\n  const signatureBytes = base64ToBytes(signature)\n  const signer = authenticators.find((a: VerificationMethod) => {\n    const { keyBytes, keyType } = extractPublicKeyBytes(a)\n    if (keyType === 'Ed25519') {\n      return ed25519.verify(signatureBytes, clear, keyBytes)\n    } else {\n      return false\n    }\n  })\n  if (!signer) throw new Error('invalid_signature: Signature invalid for JWT')\n  return signer\n}\n\ntype Verifier = (data: string, signature: string, authenticators: VerificationMethod[]) => VerificationMethod\n\ntype Algorithms = Record<KNOWN_JWA, Verifier>\n\nconst algorithms: Algorithms = {\n  ES256: verifyES256,\n  ES256K: verifyES256K,\n  // This is a non-standard algorithm but retained for backwards compatibility\n  // see https://github.com/decentralized-identity/did-jwt/issues/146\n  'ES256K-R': verifyRecoverableES256K,\n  // This is actually incorrect but retained for backwards compatibility\n  // see https://github.com/decentralized-identity/did-jwt/issues/130\n  Ed25519: verifyEd25519,\n  EdDSA: verifyEd25519,\n}\n\nfunction VerifierAlgorithm(alg: string): Verifier {\n  const impl: Verifier = algorithms[alg as KNOWN_JWA]\n  if (!impl) throw new Error(`not_supported: Unsupported algorithm ${alg}`)\n  return impl\n}\n\nVerifierAlgorithm.toSignatureObject = toSignatureObject\n\nexport default VerifierAlgorithm","/**\n * Error prefixes used for known verification failure cases.\n *\n * For compatibility, these error prefixes match the existing error messages, but will be adjusted in a future major\n * version update to match the scenarios better.\n *\n * @beta\n */\nexport const JWT_ERROR = {\n  /**\n   * Thrown when a JWT payload schema is unexpected or when validity period does not match\n   */\n  INVALID_JWT: 'invalid_jwt',\n  /**\n   * Thrown when the verifier audience does not match the one set in the JWT payload\n   */\n  INVALID_AUDIENCE: 'invalid_config',\n  /**\n   * Thrown when none of the public keys of the issuer match the signature of the JWT.\n   *\n   * This is equivalent to `NO_SUITABLE_KEYS` when the `proofPurpose` is NOT specified.\n   */\n  INVALID_SIGNATURE: 'invalid_signature',\n  /**\n   * Thrown when the DID document of the issuer does not have any keys that match the signature for the given\n   * `proofPurpose`.\n   *\n   * This is equivalent to `invalid_signature`, when a `proofPurpose` is specified.\n   */\n  NO_SUITABLE_KEYS: 'no_suitable_keys',\n  /**\n   * Thrown when the `alg` of the JWT or the encoding of the key is not supported\n   */\n  NOT_SUPPORTED: 'not_supported',\n  /**\n   * Thrown when the DID resolver is unable to resolve the issuer DID.\n   */\n  RESOLVER_ERROR: 'resolver_error',\n}\n","import type { VerificationMethod } from 'did-resolver'\nimport { JWT_ERROR } from './Errors.js'\nimport { type JWTDecoded, type JWTVerifyOptions, resolveAuthenticator, verifyJWT, verifyJWTDecoded } from './JWT.js'\n\nexport const CONDITIONAL_PROOF_2022 = 'ConditionalProof2022'\n\nexport async function verifyProof(\n  jwt: string,\n  { header, payload, signature, data }: JWTDecoded,\n  authenticator: VerificationMethod,\n  options: JWTVerifyOptions\n): Promise<VerificationMethod> {\n  if (authenticator.type === CONDITIONAL_PROOF_2022) {\n    return verifyConditionalProof(jwt, { payload, header, signature, data }, authenticator, options)\n  } else {\n    return verifyJWTDecoded({ header, payload, data, signature }, [authenticator])\n  }\n}\n\nexport async function verifyConditionalProof(\n  jwt: string,\n  { header, payload, signature, data }: JWTDecoded,\n  authenticator: VerificationMethod,\n  options: JWTVerifyOptions\n): Promise<VerificationMethod> {\n  // Validate the condition according to its condition property\n  if (authenticator.conditionWeightedThreshold) {\n    return verifyConditionWeightedThreshold(jwt, { header, payload, data, signature }, authenticator, options)\n  } else if (authenticator.conditionDelegated) {\n    return verifyConditionDelegated(jwt, { header, payload, data, signature }, authenticator, options)\n  }\n  // TODO other conditions\n\n  throw new Error(\n    `${JWT_ERROR.INVALID_JWT}: conditional proof type did not find condition for authenticator ${authenticator.id}.`\n  )\n}\n\nasync function verifyConditionWeightedThreshold(\n  jwt: string,\n  { header, payload, data, signature }: JWTDecoded,\n  authenticator: VerificationMethod,\n  options: JWTVerifyOptions\n): Promise<VerificationMethod> {\n  if (!authenticator.conditionWeightedThreshold || !authenticator.threshold) {\n    throw new Error('Expected conditionWeightedThreshold and threshold')\n  }\n\n  const issuers: string[] = []\n  const threshold = authenticator.threshold\n  let weightCount = 0\n\n  for (const weightedCondition of authenticator.conditionWeightedThreshold) {\n    const currentCondition = weightedCondition.condition\n    let foundSigner: VerificationMethod | undefined\n\n    try {\n      if (currentCondition.type === CONDITIONAL_PROOF_2022) {\n        if (!options.didAuthenticator) {\n          throw new Error('Expected didAuthenticator')\n        }\n\n        const newOptions: JWTVerifyOptions = {\n          ...options,\n          didAuthenticator: {\n            didResolutionResult: options.didAuthenticator?.didResolutionResult,\n            authenticators: [currentCondition],\n            issuer: currentCondition.id,\n          },\n        }\n        const { verified } = await verifyJWT(jwt, newOptions)\n        if (verified) {\n          foundSigner = currentCondition\n        }\n      } else {\n        foundSigner = await verifyJWTDecoded({ header, payload, data, signature }, currentCondition)\n      }\n    } catch (e) {\n      if (!(e as Error).message.startsWith(JWT_ERROR.INVALID_SIGNATURE)) throw e\n    }\n\n    if (foundSigner && !issuers.includes(foundSigner.id)) {\n      issuers.push(foundSigner.id)\n      weightCount += weightedCondition.weight\n\n      if (weightCount >= threshold) {\n        return authenticator\n      }\n    }\n  }\n  throw new Error(`${JWT_ERROR.INVALID_SIGNATURE}: condition for authenticator ${authenticator.id} is not met.`)\n}\n\nasync function verifyConditionDelegated(\n  jwt: string,\n  { header, payload, data, signature }: JWTDecoded,\n  authenticator: VerificationMethod,\n  options: JWTVerifyOptions\n): Promise<VerificationMethod> {\n  if (!authenticator.conditionDelegated) {\n    throw new Error('Expected conditionDelegated')\n  }\n  if (!options.resolver) {\n    throw new Error('Expected resolver')\n  }\n\n  let foundSigner: VerificationMethod | undefined\n\n  const issuer = authenticator.conditionDelegated\n  const didAuthenticator = await resolveAuthenticator(options.resolver, header.alg, issuer, options.proofPurpose)\n  const didResolutionResult = didAuthenticator.didResolutionResult\n\n  if (!didResolutionResult?.didDocument) {\n    throw new Error(`${JWT_ERROR.RESOLVER_ERROR}: Could not resolve delegated DID ${issuer}.`)\n  }\n\n  const delegatedAuthenticator = didAuthenticator.authenticators.find((authenticator) => authenticator.id === issuer)\n  if (!delegatedAuthenticator) {\n    throw new Error(\n      `${JWT_ERROR.NO_SUITABLE_KEYS}: Could not find delegated authenticator ${issuer} in it's DID Document`\n    )\n  }\n\n  if (delegatedAuthenticator.type === CONDITIONAL_PROOF_2022) {\n    const { verified } = await verifyJWT(jwt, {\n      ...options,\n      ...{\n        didAuthenticator: {\n          didResolutionResult,\n          authenticators: [delegatedAuthenticator],\n          issuer: delegatedAuthenticator.id,\n        },\n      },\n    })\n    if (verified) {\n      foundSigner = delegatedAuthenticator\n    }\n  } else {\n    try {\n      foundSigner = verifyJWTDecoded({ header, payload, data, signature }, delegatedAuthenticator)\n    } catch (e) {\n      if (!(e as Error).message.startsWith('invalid_signature:')) throw e\n    }\n  }\n\n  if (foundSigner) {\n    return authenticator\n  }\n\n  throw new Error(`${JWT_ERROR.INVALID_SIGNATURE}: condition for authenticator ${authenticator.id} is not met.`)\n}\n","import canonicalizeData from 'canonicalize'\nimport { DIDDocument, DIDResolutionResult, parse, ParsedDID, Resolvable, VerificationMethod } from 'did-resolver'\nimport SignerAlg from './SignerAlgorithm.js'\nimport { decodeBase64url, EcdsaSignature, encodeBase64url, KNOWN_JWA, SUPPORTED_PUBLIC_KEY_TYPES } from './util.js'\nimport VerifierAlgorithm from './VerifierAlgorithm.js'\nimport { JWT_ERROR } from './Errors.js'\nimport { verifyProof } from './ConditionalAlgorithm.js'\n\nexport type Signer = (data: string | Uint8Array) => Promise<EcdsaSignature | string>\nexport type SignerAlgorithm = (payload: string, signer: Signer) => Promise<string>\n\nexport type ProofPurposeTypes =\n  | 'assertionMethod'\n  | 'authentication'\n  // | 'keyAgreement' // keyAgreement VerificationMethod should not be used for signing\n  | 'capabilityDelegation'\n  | 'capabilityInvocation'\n\nexport interface JWTOptions {\n  issuer: string\n  signer: Signer\n  /**\n   * @deprecated Please use `header.alg` to specify the JWT algorithm.\n   */\n  alg?: string\n  expiresIn?: number\n  canonicalize?: boolean\n}\n\nexport interface JWTVerifyOptions {\n  /** @deprecated Please use `proofPurpose: 'authentication' instead` */\n  auth?: boolean\n  audience?: string\n  callbackUrl?: string\n  resolver?: Resolvable\n  skewTime?: number\n  /** See https://www.w3.org/TR/did-spec-registries/#verification-relationships */\n  proofPurpose?: ProofPurposeTypes\n  policies?: JWTVerifyPolicies\n  didAuthenticator?: DIDAuthenticator\n}\n\n/**\n * Overrides the different types of checks performed on the JWT besides the signature check\n */\nexport interface JWTVerifyPolicies {\n  // overrides the timestamp against which the validity interval is checked\n  now?: number\n  // when set to false, the timestamp checks ignore the Not Before(`nbf`) property\n  nbf?: boolean\n  // when set to false, the timestamp checks ignore the Issued At(`iat`) property\n  iat?: boolean\n  // when set to false, the timestamp checks ignore the Expires At(`exp`) property\n  exp?: boolean\n  // when set to false, the JWT audience check is skipped\n  aud?: boolean\n}\n\nexport interface JWSCreationOptions {\n  canonicalize?: boolean\n}\n\nexport interface DIDAuthenticator {\n  authenticators: VerificationMethod[]\n  issuer: string\n  didResolutionResult: DIDResolutionResult\n}\n\nexport interface JWTHeader {\n  typ: 'JWT'\n  alg: string\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [x: string]: any\n}\n\nexport interface JWTPayload {\n  iss?: string\n  sub?: string\n  aud?: string | string[]\n  iat?: number\n  nbf?: number\n  exp?: number\n  rexp?: number\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [x: string]: any\n}\n\nexport interface JWTDecoded {\n  header: JWTHeader\n  payload: JWTPayload\n  signature: string\n  data: string\n}\n\nexport interface JWSDecoded {\n  header: JWTHeader\n  payload: string\n  signature: string\n  data: string\n}\n\n/**\n * Result object returned by {@link verifyJWT}\n */\nexport interface JWTVerified {\n  /**\n   * Set to true for a JWT that passes all the required checks minus any verification overrides.\n   */\n  verified: true\n\n  /**\n   * The decoded JWT payload\n   */\n  payload: Partial<JWTPayload>\n\n  /**\n   * The result of resolving the issuer DID\n   */\n  didResolutionResult: DIDResolutionResult\n\n  /**\n   * the issuer DID\n   */\n  issuer: string\n\n  /**\n   * The public key of the issuer that matches the JWT signature\n   */\n  signer: VerificationMethod\n\n  /**\n   * The original JWT that was verified\n   */\n  jwt: string\n\n  /**\n   * Any overrides that were used during verification\n   */\n  policies?: JWTVerifyPolicies\n}\n\nexport const SELF_ISSUED_V2 = 'https://self-issued.me/v2'\nexport const SELF_ISSUED_V2_VC_INTEROP = 'https://self-issued.me/v2/openid-vc' // https://identity.foundation/jwt-vc-presentation-profile/#id-token-validation\nexport const SELF_ISSUED_V0_1 = 'https://self-issued.me'\n\ntype LegacyVerificationMethod = { publicKey?: string }\n\nconst defaultAlg: KNOWN_JWA = 'ES256K'\nconst DID_JSON = 'application/did+json'\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction encodeSection(data: any, shouldCanonicalize = false): string {\n  if (shouldCanonicalize) {\n    return encodeBase64url(<string>canonicalizeData(data))\n  } else {\n    return encodeBase64url(JSON.stringify(data))\n  }\n}\n\nexport const NBF_SKEW = 300\n\nfunction decodeJWS(jws: string): JWSDecoded {\n  const parts = jws.match(/^([a-zA-Z0-9_-]+)\\.([a-zA-Z0-9_-]+)\\.([a-zA-Z0-9_-]+)$/)\n  if (parts) {\n    return {\n      header: JSON.parse(decodeBase64url(parts[1])),\n      payload: parts[2],\n      signature: parts[3],\n      data: `${parts[1]}.${parts[2]}`,\n    }\n  }\n  throw new Error('invalid_argument: Incorrect format JWS')\n}\n\n/**\n *  Decodes a JWT and returns an object representing the payload\n *\n *  @example\n *  decodeJWT('eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJpYXQiOjE1...')\n *\n *  @param    {String}            jwt                a JSON Web Token to verify\n * @param    {Object}            [recurse]          whether to recurse into the payload to decode any nested JWTs\n *  @return   {Object}                               a JS object representing the decoded JWT\n */\nexport function decodeJWT(jwt: string, recurse = true): JWTDecoded {\n  if (!jwt) throw new Error('invalid_argument: no JWT passed into decodeJWT')\n  try {\n    const jws = decodeJWS(jwt)\n    const decodedJwt: JWTDecoded = Object.assign(jws, { payload: JSON.parse(decodeBase64url(jws.payload)) })\n    const iss = decodedJwt.payload.iss\n\n    if (decodedJwt.header.cty === 'JWT' && recurse) {\n      const innerDecodedJwt = decodeJWT(decodedJwt.payload.jwt)\n\n      if (innerDecodedJwt.payload.iss !== iss) throw new Error(`${JWT_ERROR.INVALID_JWT}: multiple issuers`)\n      return innerDecodedJwt\n    }\n    return decodedJwt\n  } catch (e) {\n    throw new Error('invalid_argument: Incorrect format JWT')\n  }\n}\n\n/**\n *  Creates a signed JWS given a payload, a signer, and an optional header.\n *\n *  @example\n *  const signer = ES256KSigner(process.env.PRIVATE_KEY)\n *  const jws = await createJWS({ my: 'payload' }, signer)\n *\n *  @param    {Object}            payload           payload object\n *  @param    {Signer}            signer            a signer, see `ES256KSigner or `EdDSASigner`\n *  @param    {Object}            header            optional object to specify or customize the JWS header\n *  @param    {Object}            options           can be used to trigger automatic canonicalization of header and\n *                                                    payload properties\n *  @return   {Promise<string>}                     a Promise which resolves to a JWS string or rejects with an error\n */\nexport async function createJWS(\n  payload: string | Partial<JWTPayload>,\n  signer: Signer,\n  header: Partial<JWTHeader> = {},\n  options: JWSCreationOptions = {}\n): Promise<string> {\n  if (!header.alg) header.alg = defaultAlg\n  const encodedPayload = typeof payload === 'string' ? payload : encodeSection(payload, options.canonicalize)\n  const signingInput: string = [encodeSection(header, options.canonicalize), encodedPayload].join('.')\n\n  const jwtSigner: SignerAlgorithm = SignerAlg(header.alg)\n  const signature: string = await jwtSigner(signingInput, signer)\n\n  // JWS Compact Serialization\n  // https://www.rfc-editor.org/rfc/rfc7515#section-7.1\n  return [signingInput, signature].join('.')\n}\n\n/**\n *  Creates a signed JWT given an address which becomes the issuer, a signer, and a payload for which the signature is\n * over.\n *\n *  @example\n *  const signer = ES256KSigner(process.env.PRIVATE_KEY)\n *  createJWT({address: '5A8bRWU3F7j3REx3vkJ...', signer}, {key1: 'value', key2: ..., ... }).then(jwt => {\n *      ...\n *  })\n *\n *  @param    {Object}            payload               payload object\n *  @param    {Object}            [options]             an unsigned credential object\n *  @param    {String}            options.issuer        The DID of the issuer (signer) of JWT\n *  @param    {String}            options.alg           [DEPRECATED] The JWT signing algorithm to use. Supports:\n *   [ES256K, ES256K-R, Ed25519, EdDSA], Defaults to: ES256K. Please use `header.alg` to specify the algorithm\n *  @param    {Signer}            options.signer        a `Signer` function, Please see `ES256KSigner` or `EdDSASigner`\n *  @param    {boolean}           options.canonicalize  optional flag to canonicalize header and payload before signing\n *  @param    {Object}            header                optional object to specify or customize the JWT header\n *  @return   {Promise<Object, Error>}                  a promise which resolves with a signed JSON Web Token or\n *   rejects with an error\n */\nexport async function createJWT(\n  payload: Partial<JWTPayload>,\n  { issuer, signer, alg, expiresIn, canonicalize }: JWTOptions,\n  header: Partial<JWTHeader> = {}\n): Promise<string> {\n  if (!signer) throw new Error('missing_signer: No Signer functionality has been configured')\n  if (!issuer) throw new Error('missing_issuer: No issuing DID has been configured')\n  if (!header.typ) header.typ = 'JWT'\n  if (!header.alg) header.alg = alg\n  const timestamps: Partial<JWTPayload> = {\n    iat: Math.floor(Date.now() / 1000),\n    exp: undefined,\n  }\n  if (expiresIn) {\n    if (typeof expiresIn === 'number') {\n      timestamps.exp = <number>(payload.nbf || timestamps.iat) + Math.floor(expiresIn)\n    } else {\n      throw new Error('invalid_argument: JWT expiresIn is not a number')\n    }\n  }\n  const fullPayload = { ...timestamps, ...payload, iss: issuer }\n  return createJWS(fullPayload, signer, header, { canonicalize })\n}\n\n/**\n *  Creates a multi-signature signed JWT given multiple issuers and their corresponding signers, and a payload for\n * which the signature is over.\n *\n *  @example\n *  const signer = ES256KSigner(process.env.PRIVATE_KEY)\n *  createJWT({address: '5A8bRWU3F7j3REx3vkJ...', signer}, {key1: 'value', key2: ..., ... }).then(jwt => {\n *      ...\n *  })\n *\n *  @param    {Object}            payload               payload object\n *  @param    {Object}            [options]             an unsigned credential object\n *  @param    {boolean}           options.expiresIn     optional flag to denote the expiration time\n *  @param    {boolean}           options.canonicalize  optional flag to canonicalize header and payload before signing\n *  @param    {Object[]}          issuers               array of the issuers, their signers and algorithms\n *  @param    {string}            issuers[].issuer      The DID of the issuer (signer) of JWT\n *  @param    {Signer}            issuers[].signer      a `Signer` function, Please see `ES256KSigner` or `EdDSASigner`\n *  @param    {String}            issuers[].alg         [DEPRECATED] The JWT signing algorithm to use. Supports:\n *   [ES256K, ES256K-R, Ed25519, EdDSA], Defaults to: ES256K. Please use `header.alg` to specify the algorithm\n *  @return   {Promise<Object, Error>}                  a promise which resolves with a signed JSON Web Token or\n *   rejects with an error\n */\nexport async function createMultisignatureJWT(\n  payload: Partial<JWTPayload>,\n  { expiresIn, canonicalize }: Partial<JWTOptions>,\n  issuers: { issuer: string; signer: Signer; alg: string }[]\n): Promise<string> {\n  if (issuers.length === 0) throw new Error('invalid_argument: must provide one or more issuers')\n\n  let payloadResult: Partial<JWTPayload> = payload\n\n  let jwt = ''\n  for (let i = 0; i < issuers.length; i++) {\n    const issuer = issuers[i]\n\n    const header: Partial<JWTHeader> = {\n      typ: 'JWT',\n      alg: issuer.alg,\n    }\n\n    // Create nested JWT\n    // See Point 5 of https://www.rfc-editor.org/rfc/rfc7519#section-7.1\n    // After the first JWT is created (the first JWS), the next JWT is created by inputting the previous JWT as the\n    // payload\n    if (i !== 0) {\n      header.cty = 'JWT'\n    }\n\n    jwt = await createJWT(payloadResult, { ...issuer, canonicalize, expiresIn }, header)\n\n    payloadResult = { jwt }\n  }\n  return jwt\n}\n\nexport function verifyJWTDecoded(\n  { header, payload, data, signature }: JWTDecoded,\n  pubKeys: VerificationMethod | VerificationMethod[]\n): VerificationMethod {\n  if (!Array.isArray(pubKeys)) pubKeys = [pubKeys]\n\n  const iss = payload.iss\n  let recurse = true\n  do {\n    if (iss !== payload.iss) throw new Error(`${JWT_ERROR.INVALID_JWT}: multiple issuers`)\n\n    try {\n      const result = VerifierAlgorithm(header.alg)(data, signature, pubKeys)\n\n      return result\n    } catch (e) {\n      if (!(e as Error).message.startsWith(JWT_ERROR.INVALID_SIGNATURE)) throw e\n    }\n\n    // TODO probably best to create copy objects than replace reference objects\n    if (header.cty !== 'JWT') {\n      recurse = false\n    } else {\n      ;({ payload, header, signature, data } = decodeJWT(payload.jwt, false))\n    }\n  } while (recurse)\n\n  throw new Error(`${JWT_ERROR.INVALID_SIGNATURE}: no matching public key found`)\n}\n\nexport function verifyJWSDecoded(\n  { header, data, signature }: JWSDecoded,\n  pubKeys: VerificationMethod | VerificationMethod[]\n): VerificationMethod {\n  if (!Array.isArray(pubKeys)) pubKeys = [pubKeys]\n  const signer: VerificationMethod = VerifierAlgorithm(header.alg)(data, signature, pubKeys)\n  return signer\n}\n\n/**\n *  Verifies given JWS. If the JWS is valid, returns the public key that was\n *  used to sign the JWS, or throws an `Error` if none of the `pubKeys` match.\n *\n *  @example\n *  const pubKey = verifyJWS('eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJyZXF1Z....', { publicKeyHex: '0x12341...' })\n *\n *  @param    {String}                          jws         A JWS string to verify\n *  @param    {Array<VerificationMethod> | VerificationMethod}    pubKeys     The public keys used to verify the JWS\n *  @return   {VerificationMethod}                       The public key used to sign the JWS\n */\nexport function verifyJWS(jws: string, pubKeys: VerificationMethod | VerificationMethod[]): VerificationMethod {\n  const jwsDecoded: JWSDecoded = decodeJWS(jws)\n  return verifyJWSDecoded(jwsDecoded, pubKeys)\n}\n\n/**\n *  Verifies given JWT. If the JWT is valid, the promise returns an object including the JWT, the payload of the JWT,\n *  and the DID document of the issuer of the JWT.\n *\n *  @example\n *  ```ts\n *  verifyJWT(\n *      'did:uport:eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJyZXF1Z....',\n *      {audience: '5A8bRWU3F7j3REx3vkJ...', callbackUrl: 'https://...'}\n *    ).then(obj => {\n *        const did = obj.did // DID of signer\n *        const payload = obj.payload\n *        const doc = obj.didResolutionResult.didDocument // DID Document of issuer\n *        const jwt = obj.jwt\n *        const signerKeyId = obj.signer.id // ID of key in DID document that signed JWT\n *        ...\n *    })\n *  ```\n *\n *  @param    {String}            jwt                a JSON Web Token to verify\n *  @param    {Object}            [options]           an unsigned credential object\n *  @param    {Boolean}           options.auth        Require signer to be listed in the authentication section of the\n *   DID document (for Authentication purposes)\n *  @param    {String}            options.audience    DID of the recipient of the JWT\n *  @param    {String}            options.callbackUrl callback url in JWT\n *  @return   {Promise<Object, Error>}               a promise which resolves with a response object or rejects with an\n *   error\n */\nexport async function verifyJWT(\n  jwt: string,\n  options: JWTVerifyOptions = {\n    resolver: undefined,\n    auth: undefined,\n    audience: undefined,\n    callbackUrl: undefined,\n    skewTime: undefined,\n    proofPurpose: undefined,\n    policies: {},\n    didAuthenticator: undefined,\n  }\n): Promise<JWTVerified> {\n  if (!options.resolver) throw new Error('missing_resolver: No DID resolver has been configured')\n  const { payload, header, signature, data }: JWTDecoded = decodeJWT(jwt, false)\n  const proofPurpose: ProofPurposeTypes | undefined = Object.prototype.hasOwnProperty.call(options, 'auth')\n    ? options.auth\n      ? 'authentication'\n      : undefined\n    : options.proofPurpose\n\n  let didUrl: string | undefined\n\n  if (!payload.iss && !payload.client_id) {\n    throw new Error(`${JWT_ERROR.INVALID_JWT}: JWT iss or client_id are required`)\n  }\n\n  if (options.didAuthenticator) {\n    didUrl = options.didAuthenticator.issuer\n  } else if (payload.iss === SELF_ISSUED_V2 || payload.iss === SELF_ISSUED_V2_VC_INTEROP) {\n    if (!payload.sub) {\n      throw new Error(`${JWT_ERROR.INVALID_JWT}: JWT sub is required`)\n    }\n    if (typeof payload.sub_jwk === 'undefined') {\n      didUrl = payload.sub\n    } else {\n      didUrl = (header.kid || '').split('#')[0]\n    }\n  } else if (payload.iss === SELF_ISSUED_V0_1) {\n    if (!payload.did) {\n      throw new Error(`${JWT_ERROR.INVALID_JWT}: JWT did is required`)\n    }\n    didUrl = payload.did\n  } else if (!payload.iss && payload.scope === 'openid' && payload.redirect_uri) {\n    // SIOP Request payload\n    // https://identity.foundation/jwt-vc-presentation-profile/#self-issued-op-request-object\n    if (!payload.client_id) {\n      throw new Error(`${JWT_ERROR.INVALID_JWT}: JWT client_id is required`)\n    }\n    didUrl = payload.client_id\n  } else {\n    didUrl = payload.iss\n  }\n\n  if (!didUrl) {\n    throw new Error(`${JWT_ERROR.INVALID_JWT}: No DID has been found in the JWT`)\n  }\n\n  let authenticators: VerificationMethod[]\n  let issuer: string\n  let didResolutionResult: DIDResolutionResult\n  if (options.didAuthenticator) {\n    ;({ didResolutionResult, authenticators, issuer } = options.didAuthenticator)\n  } else {\n    ;({ didResolutionResult, authenticators, issuer } = await resolveAuthenticator(\n      options.resolver,\n      header.alg,\n      didUrl,\n      proofPurpose\n    ))\n    // Add to options object for recursive reference\n    options.didAuthenticator = { didResolutionResult, authenticators, issuer }\n  }\n\n  const { did } = parse(didUrl) as ParsedDID\n\n  let signer: VerificationMethod | null = null\n\n  if (did !== didUrl) {\n    const authenticator = authenticators.find((auth) => auth.id === didUrl)\n    if (!authenticator) {\n      throw new Error(`${JWT_ERROR.INVALID_JWT}: No authenticator found for did URL ${didUrl}`)\n    }\n\n    signer = await verifyProof(jwt, { payload, header, signature, data }, authenticator, options)\n  } else {\n    let i = 0\n    while (!signer && i < authenticators.length) {\n      const authenticator = authenticators[i]\n      try {\n        signer = await verifyProof(jwt, { payload, header, signature, data }, authenticator, options)\n      } catch (e) {\n        if (!(e as Error).message.includes(JWT_ERROR.INVALID_SIGNATURE) || i === authenticators.length - 1) throw e\n      }\n\n      i++\n    }\n  }\n\n  if (signer) {\n    const now: number = typeof options.policies?.now === 'number' ? options.policies.now : Math.floor(Date.now() / 1000)\n    const skewTime = typeof options.skewTime !== 'undefined' && options.skewTime >= 0 ? options.skewTime : NBF_SKEW\n\n    const nowSkewed = now + skewTime\n    if (options.policies?.nbf !== false && payload.nbf) {\n      if (payload.nbf > nowSkewed) {\n        throw new Error(`${JWT_ERROR.INVALID_JWT}: JWT not valid before nbf: ${payload.nbf}`)\n      }\n    } else if (options.policies?.iat !== false && payload.iat && payload.iat > nowSkewed) {\n      throw new Error(`${JWT_ERROR.INVALID_JWT}: JWT not valid yet (issued in the future) iat: ${payload.iat}`)\n    }\n    if (options.policies?.exp !== false && payload.exp && payload.exp <= now - skewTime) {\n      throw new Error(`${JWT_ERROR.INVALID_JWT}: JWT has expired: exp: ${payload.exp} < now: ${now}`)\n    }\n    if (options.policies?.aud !== false && payload.aud) {\n      if (!options.audience && !options.callbackUrl) {\n        throw new Error(\n          `${JWT_ERROR.INVALID_AUDIENCE}: JWT audience is required but your app address has not been configured`\n        )\n      }\n      const audArray = Array.isArray(payload.aud) ? payload.aud : [payload.aud]\n      const matchedAudience = audArray.find((item) => options.audience === item || options.callbackUrl === item)\n\n      if (typeof matchedAudience === 'undefined') {\n        throw new Error(`${JWT_ERROR.INVALID_AUDIENCE}: JWT audience does not match your DID or callback url`)\n      }\n    }\n\n    return { verified: true, payload, didResolutionResult, issuer, signer, jwt, policies: options.policies }\n  }\n  throw new Error(\n    `${JWT_ERROR.INVALID_SIGNATURE}: JWT not valid. issuer DID document does not contain a verificationMethod that matches the signature.`\n  )\n}\n\n/**\n * Resolves relevant public keys or other authenticating material used to verify signature from the DID document of\n * provided DID\n *\n *  @example\n *  ```ts\n *  resolveAuthenticator(resolver, 'ES256K', 'did:uport:2nQtiQG6Cgm1GYTBaaKAgr76uY7iSexUkqX').then(obj => {\n *      const payload = obj.payload\n *      const profile = obj.profile\n *      const jwt = obj.jwt\n *      // ...\n *  })\n *  ```\n *\n *  @param resolver - {Resolvable} a DID resolver function that can obtain the `DIDDocument` for the `issuer`\n *  @param alg - {String} a JWT algorithm\n *  @param issuer - {String} a Decentralized Identifier (DID) to lookup\n *  @param proofPurpose - {ProofPurposeTypes} *Optional* Use the verificationMethod linked in that section of the\n *   issuer DID document\n *  @return {Promise<DIDAuthenticator>} a promise which resolves with an object containing an array of authenticators\n *   or rejects with an error if none exist\n */\nexport async function resolveAuthenticator(\n  resolver: Resolvable,\n  alg: string,\n  issuer: string,\n  proofPurpose?: ProofPurposeTypes\n): Promise<DIDAuthenticator> {\n  const types: string[] = SUPPORTED_PUBLIC_KEY_TYPES[alg as KNOWN_JWA]\n  if (!types || types.length === 0) {\n    throw new Error(`${JWT_ERROR.NOT_SUPPORTED}: No supported signature types for algorithm ${alg}`)\n  }\n  let didResult: DIDResolutionResult\n\n  const result = (await resolver.resolve(issuer, { accept: DID_JSON })) as unknown\n  // support legacy resolvers that do not produce DIDResolutionResult\n  if (Object.getOwnPropertyNames(result).indexOf('didDocument') === -1) {\n    didResult = {\n      didDocument: result as DIDDocument,\n      didDocumentMetadata: {},\n      didResolutionMetadata: { contentType: DID_JSON },\n    }\n  } else {\n    didResult = result as DIDResolutionResult\n  }\n\n  if (didResult.didResolutionMetadata?.error || didResult.didDocument == null) {\n    const { error, message } = didResult.didResolutionMetadata\n    throw new Error(\n      `${JWT_ERROR.RESOLVER_ERROR}: Unable to resolve DID document for ${issuer}: ${error}, ${message || ''}`\n    )\n  }\n\n  const getPublicKeyById = (verificationMethods: VerificationMethod[], pubid?: string): VerificationMethod | null => {\n    const filtered = verificationMethods.filter(({ id }) => pubid === id)\n    return filtered.length > 0 ? filtered[0] : null\n  }\n\n  let publicKeysToCheck: VerificationMethod[] = [\n    ...(didResult?.didDocument?.verificationMethod || []),\n    ...(didResult?.didDocument?.publicKey || []),\n  ]\n  if (typeof proofPurpose === 'string') {\n    // support legacy DID Documents that do not list assertionMethod\n    if (\n      proofPurpose.startsWith('assertion') &&\n      !Object.getOwnPropertyNames(didResult?.didDocument).includes('assertionMethod')\n    ) {\n      didResult.didDocument = { ...(<DIDDocument>didResult.didDocument) }\n      didResult.didDocument.assertionMethod = [...publicKeysToCheck.map((pk) => pk.id)]\n    }\n\n    publicKeysToCheck = (didResult.didDocument[proofPurpose] || [])\n      .map((verificationMethod) => {\n        if (typeof verificationMethod === 'string') {\n          return getPublicKeyById(publicKeysToCheck, verificationMethod)\n        } else if (typeof (<LegacyVerificationMethod>verificationMethod).publicKey === 'string') {\n          // this is a legacy format\n          return getPublicKeyById(publicKeysToCheck, (<LegacyVerificationMethod>verificationMethod).publicKey)\n        } else {\n          return <VerificationMethod>verificationMethod\n        }\n      })\n      .filter((key) => key != null) as VerificationMethod[]\n  }\n\n  const authenticators: VerificationMethod[] = publicKeysToCheck.filter(({ type }) =>\n    types.find((supported) => supported === type)\n  )\n\n  if (typeof proofPurpose === 'string' && (!authenticators || authenticators.length === 0)) {\n    throw new Error(\n      `${JWT_ERROR.NO_SUITABLE_KEYS}: DID document for ${issuer} does not have public keys suitable for ${alg} with ${proofPurpose} purpose`\n    )\n  }\n  if (!authenticators || authenticators.length === 0) {\n    throw new Error(`${JWT_ERROR.NO_SUITABLE_KEYS}: DID document for ${issuer} does not have public keys for ${alg}`)\n  }\n  return { authenticators, issuer, didResolutionResult: didResult }\n}\n","import { base64ToBytes, bytesToBase64url, decodeBase64url, stringToBytes, toSealed } from '../util.js'\nimport type { Decrypter, Encrypter, EncryptionResult, EphemeralKeyPair, JWE, ProtectedHeader } from './types.js'\n\nfunction validateJWE(jwe: JWE) {\n  if (!(jwe.protected && jwe.iv && jwe.ciphertext && jwe.tag)) {\n    throw new Error('bad_jwe: missing properties')\n  }\n  if (jwe.recipients) {\n    jwe.recipients.map((rec) => {\n      if (!(rec.header && rec.encrypted_key)) {\n        throw new Error('bad_jwe: malformed recipients')\n      }\n    })\n  }\n}\n\nfunction encodeJWE({ ciphertext, tag, iv, protectedHeader, recipient }: EncryptionResult, aad?: Uint8Array): JWE {\n  const jwe: JWE = {\n    protected: <string>protectedHeader,\n    iv: bytesToBase64url(iv ?? new Uint8Array(0)),\n    ciphertext: bytesToBase64url(ciphertext),\n    tag: bytesToBase64url(tag ?? new Uint8Array(0)),\n  }\n  if (aad) jwe.aad = bytesToBase64url(aad)\n  if (recipient) jwe.recipients = [recipient]\n  return jwe\n}\n\nexport async function createJWE(\n  cleartext: Uint8Array,\n  encrypters: Encrypter[],\n  protectedHeader: ProtectedHeader = {},\n  aad?: Uint8Array,\n  useSingleEphemeralKey = false\n): Promise<JWE> {\n  if (encrypters[0].alg === 'dir') {\n    if (encrypters.length > 1) throw new Error('not_supported: Can only do \"dir\" encryption to one key.')\n    const encryptionResult = await encrypters[0].encrypt(cleartext, protectedHeader, aad)\n    return encodeJWE(encryptionResult, aad)\n  } else {\n    const tmpEnc = encrypters[0].enc\n    if (!encrypters.reduce((acc, encrypter) => acc && encrypter.enc === tmpEnc, true)) {\n      throw new Error('invalid_argument: Incompatible encrypters passed')\n    }\n    let cek: Uint8Array | undefined\n    let jwe: JWE | undefined\n    let epk: EphemeralKeyPair | undefined\n    if (useSingleEphemeralKey) {\n      epk = encrypters[0].genEpk?.()\n      const alg = encrypters[0].alg\n      protectedHeader = { ...protectedHeader, alg, epk: epk?.publicKeyJWK }\n    }\n\n    for (const encrypter of encrypters) {\n      if (!cek) {\n        const encryptionResult = await encrypter.encrypt(cleartext, protectedHeader, aad, epk)\n        cek = encryptionResult.cek\n        jwe = encodeJWE(encryptionResult, aad)\n      } else {\n        const recipient = await encrypter.encryptCek?.(cek, epk)\n        if (recipient) {\n          jwe?.recipients?.push(recipient)\n        }\n      }\n    }\n    return <JWE>jwe\n  }\n}\n\nexport async function decryptJWE(jwe: JWE, decrypter: Decrypter): Promise<Uint8Array> {\n  validateJWE(jwe)\n  const protHeader = JSON.parse(decodeBase64url(jwe.protected))\n  if (protHeader.enc !== decrypter.enc)\n    throw new Error(`not_supported: Decrypter does not supported: '${protHeader.enc}'`)\n  const sealed = toSealed(jwe.ciphertext, jwe.tag)\n  const aad = stringToBytes(jwe.aad ? `${jwe.protected}.${jwe.aad}` : jwe.protected)\n  let cleartext = null\n  if (protHeader.alg === 'dir' && decrypter.alg === 'dir') {\n    cleartext = await decrypter.decrypt(sealed, base64ToBytes(jwe.iv), aad)\n  } else if (!jwe.recipients || jwe.recipients.length === 0) {\n    throw new Error('bad_jwe: missing recipients')\n  } else {\n    for (let i = 0; !cleartext && i < jwe.recipients.length; i++) {\n      const recipient = jwe.recipients[i]\n      Object.assign(recipient.header, protHeader)\n      if (recipient.header.alg === decrypter.alg) {\n        cleartext = await decrypter.decrypt(sealed, base64ToBytes(jwe.iv), aad, recipient)\n      }\n    }\n  }\n  if (cleartext === null) throw new Error('failure: Failed to decrypt')\n  return cleartext\n}\n","import type { Decrypter, Encrypter, EncryptionResult, ProtectedHeader } from './types.js'\nimport { bytesToBase64url, encodeBase64url, stringToBytes } from '../util.js'\nimport { xchacha20poly1305 } from '@noble/ciphers/chacha'\nimport { randomBytes } from '@noble/hashes/utils'\n\nexport function xc20pEncrypter(key: Uint8Array): (cleartext: Uint8Array, aad?: Uint8Array) => EncryptionResult {\n  return (cleartext: Uint8Array, aad?: Uint8Array) => {\n    const iv = randomBytes(24)\n    const cipher = xchacha20poly1305(key, iv, aad)\n    const sealed = cipher.encrypt(cleartext)\n    return {\n      ciphertext: sealed.subarray(0, sealed.length - 16),\n      tag: sealed.subarray(sealed.length - 16),\n      iv,\n    }\n  }\n}\n\nexport function xc20pDirEncrypter(key: Uint8Array): Encrypter {\n  const xc20pEncrypt = xc20pEncrypter(key)\n  const enc = 'XC20P'\n  const alg = 'dir'\n\n  async function encrypt(\n    cleartext: Uint8Array,\n    protectedHeader: ProtectedHeader = {},\n    aad?: Uint8Array\n  ): Promise<EncryptionResult> {\n    const protHeader = encodeBase64url(JSON.stringify(Object.assign({ alg }, protectedHeader, { enc })))\n    const encodedAad = stringToBytes(aad ? `${protHeader}.${bytesToBase64url(aad)}` : protHeader)\n    return {\n      ...xc20pEncrypt(cleartext, encodedAad),\n      protectedHeader: protHeader,\n    }\n  }\n\n  return { alg, enc, encrypt }\n}\n\nexport function xc20pDirDecrypter(key: Uint8Array): Decrypter {\n  async function decrypt(sealed: Uint8Array, iv: Uint8Array, aad?: Uint8Array): Promise<Uint8Array | null> {\n    try {\n      return xchacha20poly1305(key, iv, aad).decrypt(sealed)\n    } catch (error) {\n      return null\n    }\n  }\n\n  return { alg: 'dir', enc: 'XC20P', decrypt }\n}\n","import type { ECDH, EphemeralKeyPair, Recipient } from './types.js'\nimport { base64ToBytes, bytesToBase64url, generateKeyPair, generateKeyPairFromSeed } from '../util.js'\nimport { concatKDF } from '../Digest.js'\nimport { x25519 } from '@noble/curves/ed25519'\n\nexport async function computeX25519EcdhEsKek(recipient: Recipient, receiverSecret: Uint8Array | ECDH, alg: string) {\n  const crv = 'X25519'\n  const keyLen = 256\n  const header = recipient.header\n  if (header.epk?.crv !== crv || typeof header.epk.x == 'undefined') return null\n  const publicKey = base64ToBytes(header.epk.x)\n  let sharedSecret\n  if (receiverSecret instanceof Uint8Array) {\n    sharedSecret = x25519.getSharedSecret(receiverSecret, publicKey)\n  } else {\n    sharedSecret = await receiverSecret(publicKey)\n  }\n\n  // Key Encryption Key\n  let producerInfo: Uint8Array | undefined = undefined\n  let consumerInfo: Uint8Array | undefined = undefined\n  if (recipient.header.apu) producerInfo = base64ToBytes(recipient.header.apu)\n  if (recipient.header.apv) consumerInfo = base64ToBytes(recipient.header.apv)\n  return concatKDF(sharedSecret, keyLen, alg, producerInfo, consumerInfo)\n}\n\nexport async function createX25519EcdhEsKek(\n  recipientPublicKey: Uint8Array,\n  senderSecret: Uint8Array | ECDH | undefined, // unused\n  alg: string,\n  apu: string | undefined, // unused\n  apv: string | undefined,\n  ephemeralKeyPair: EphemeralKeyPair | undefined\n) {\n  const crv = 'X25519'\n  const keyLen = 256\n  const ephemeral = ephemeralKeyPair ? generateKeyPairFromSeed(ephemeralKeyPair.secretKey) : generateKeyPair()\n  const epk = { kty: 'OKP', crv, x: bytesToBase64url(ephemeral.publicKey) }\n  const sharedSecret = x25519.getSharedSecret(ephemeral.secretKey, recipientPublicKey)\n  // Key Encryption Key\n  const consumerInfo = base64ToBytes(apv ?? '')\n  const kek = concatKDF(sharedSecret, keyLen, alg, undefined, consumerInfo)\n  return { epk, kek }\n}\n","import type { ECDH, EphemeralKeyPair, Recipient } from './types.js'\nimport { base64ToBytes, bytesToBase64url, generateKeyPair, generateKeyPairFromSeed } from '../util.js'\nimport { concatKDF } from '../Digest.js'\nimport { x25519 } from '@noble/curves/ed25519'\nexport async function computeX25519Ecdh1PUv3Kek(\n  recipient: Recipient,\n  recipientSecret: Uint8Array | ECDH,\n  senderPublicKey: Uint8Array,\n  alg: string\n) {\n  const crv = 'X25519'\n  const keyLen = 256\n  const header = recipient.header\n  if (header.epk?.crv !== crv || typeof header.epk.x == 'undefined') return null\n  // ECDH-1PU requires additional shared secret between\n  // static key of sender and static key of recipient\n  const publicKey = base64ToBytes(header.epk.x)\n  let zE: Uint8Array\n  let zS: Uint8Array\n\n  if (recipientSecret instanceof Uint8Array) {\n    zE = x25519.getSharedSecret(recipientSecret, publicKey)\n    zS = x25519.getSharedSecret(recipientSecret, senderPublicKey)\n  } else {\n    zE = await recipientSecret(publicKey)\n    zS = await recipientSecret(senderPublicKey)\n  }\n\n  const sharedSecret = new Uint8Array(zE.length + zS.length)\n  sharedSecret.set(zE)\n  sharedSecret.set(zS, zE.length)\n\n  // Key Encryption Key\n  let producerInfo\n  let consumerInfo\n  if (recipient.header.apu) producerInfo = base64ToBytes(recipient.header.apu)\n  if (recipient.header.apv) consumerInfo = base64ToBytes(recipient.header.apv)\n\n  return concatKDF(sharedSecret, keyLen, alg, producerInfo, consumerInfo)\n}\n\nexport async function createX25519Ecdh1PUv3Kek(\n  recipientPublicKey: Uint8Array,\n  senderSecret: Uint8Array | ECDH,\n  alg: string, // must be provided as this is the key agreement alg + the key wrapper alg, Example: 'ECDH-ES+A256KW'\n  apu: string | undefined,\n  apv: string | undefined,\n  ephemeralKeyPair: EphemeralKeyPair | undefined\n) {\n  const crv = 'X25519'\n  const keyLen = 256\n  const ephemeral = ephemeralKeyPair ? generateKeyPairFromSeed(ephemeralKeyPair.secretKey) : generateKeyPair()\n  const epk = { kty: 'OKP', crv, x: bytesToBase64url(ephemeral.publicKey) }\n  const zE = x25519.getSharedSecret(ephemeral.secretKey, recipientPublicKey)\n\n  // ECDH-1PU requires additional shared secret between\n  // static key of sender and static key of recipient\n  let zS\n  if (senderSecret instanceof Uint8Array) {\n    zS = x25519.getSharedSecret(senderSecret, recipientPublicKey)\n  } else {\n    zS = await senderSecret(recipientPublicKey)\n  }\n\n  const sharedSecret = new Uint8Array(zE.length + zS.length)\n  sharedSecret.set(zE)\n  sharedSecret.set(zS, zE.length)\n\n  let partyUInfo: Uint8Array = new Uint8Array(0)\n  let partyVInfo: Uint8Array = new Uint8Array(0)\n  if (apu) partyUInfo = base64ToBytes(apu)\n  if (apv) partyVInfo = base64ToBytes(apv)\n\n  // Key Encryption Key\n  const kek = concatKDF(sharedSecret, keyLen, alg, partyUInfo, partyVInfo)\n  return { epk, kek }\n}\n","import { x25519 } from '@noble/curves/ed25519'\nimport type { ECDH } from './types.js'\n\n/**\n * Wraps an X25519 secret key into an ECDH method that can be used to compute a shared secret with a public key.\n * @param mySecretKey A `Uint8Array` of length 32 representing the bytes of my secret key\n * @returns an `ECDH` method with the signature `(theirPublicKey: Uint8Array) => Promise<Uint8Array>`\n *\n * @throws 'invalid_argument:...' if the secret key size is wrong\n */\nexport function createX25519ECDH(mySecretKey: Uint8Array): ECDH {\n  if (mySecretKey.length !== 32) {\n    throw new Error('invalid_argument: incorrect secret key length for X25519')\n  }\n  return async (theirPublicKey: Uint8Array): Promise<Uint8Array> => {\n    if (theirPublicKey.length !== 32) {\n      throw new Error('invalid_argument: incorrect publicKey key length for X25519')\n    }\n    return x25519.getSharedSecret(mySecretKey, theirPublicKey)\n  }\n}\n","import type {\n  AuthEncryptParams,\n  ContentEncrypter,\n  ECDH,\n  Encrypter,\n  EncryptionResult,\n  EphemeralKeyPair,\n  KekCreator,\n  KeyWrapper,\n  ProtectedHeader,\n  Recipient,\n} from './types.js'\nimport { bytesToBase64url, genX25519EphemeralKeyPair } from '../util.js'\nimport { randomBytes } from '@noble/hashes/utils'\n\nexport function createFullEncrypter(\n  recipientPublicKey: Uint8Array,\n  senderSecret: Uint8Array | ECDH | undefined,\n  options: Partial<AuthEncryptParams> = {},\n  kekCreator: KekCreator,\n  keyWrapper: KeyWrapper,\n  contentEncrypter: ContentEncrypter\n): Encrypter {\n  async function encryptCek(cek: Uint8Array, ephemeralKeyPair?: EphemeralKeyPair): Promise<Recipient> {\n    const { epk, kek } = await kekCreator.createKek(\n      recipientPublicKey,\n      senderSecret,\n      `${kekCreator.alg}+${keyWrapper.alg}`,\n      options.apu,\n      options.apv,\n      ephemeralKeyPair\n    )\n    const res = await keyWrapper.from(kek).wrap(cek)\n    const recipient: Recipient = {\n      encrypted_key: bytesToBase64url(res.ciphertext),\n      header: {},\n    }\n    if (res.iv) recipient.header.iv = bytesToBase64url(res.iv)\n    if (res.tag) recipient.header.tag = bytesToBase64url(res.tag)\n    if (options.kid) recipient.header.kid = options.kid\n    if (options.apu) recipient.header.apu = options.apu\n    if (options.apv) recipient.header.apv = options.apv\n    if (!ephemeralKeyPair) {\n      recipient.header.alg = `${kekCreator.alg}+${keyWrapper.alg}`\n      recipient.header.epk = epk\n    }\n\n    return recipient\n  }\n\n  async function encrypt(\n    cleartext: Uint8Array,\n    protectedHeader: ProtectedHeader = {},\n    aad?: Uint8Array,\n    ephemeralKeyPair?: EphemeralKeyPair\n  ): Promise<EncryptionResult> {\n    // we won't want alg to be set to dir from xc20pDirEncrypter\n    Object.assign(protectedHeader, { alg: undefined })\n    // Content Encryption Key\n    const cek = randomBytes(32)\n    const recipient: Recipient = await encryptCek(cek, ephemeralKeyPair)\n    // getting an ephemeral key means the epk is set only once per all recipients\n    if (ephemeralKeyPair) {\n      protectedHeader.alg = `${kekCreator.alg}+${keyWrapper.alg}`\n      protectedHeader.epk = ephemeralKeyPair.publicKeyJWK\n    }\n    return {\n      ...(await contentEncrypter.from(cek).encrypt(cleartext, protectedHeader, aad)),\n      recipient,\n      cek,\n    }\n  }\n\n  return { alg: keyWrapper.alg, enc: contentEncrypter.enc, encrypt, encryptCek, genEpk: genX25519EphemeralKeyPair }\n}\n","import type { Resolvable, VerificationMethod } from 'did-resolver'\nimport type {\n  AnonEncryptParams,\n  AuthEncryptParams,\n  Decrypter,\n  ECDH,\n  Encrypter,\n  KeyWrapper,\n  ProtectedHeader,\n  Recipient,\n  WrappingResult,\n} from './types.js'\nimport { base64ToBytes, extractPublicKeyBytes, isDefined, toSealed } from '../util.js'\nimport { xc20pDirDecrypter, xc20pDirEncrypter, xc20pEncrypter } from './xc20pDir.js'\nimport { computeX25519Ecdh1PUv3Kek, createX25519Ecdh1PUv3Kek } from './X25519-ECDH-1PU.js'\nimport { computeX25519EcdhEsKek, createX25519EcdhEsKek } from './X25519-ECDH-ES.js'\nimport { createFullEncrypter } from './createEncrypter.js'\n\n/**\n * @deprecated Use\n *   {@link xc20pAuthEncrypterEcdh1PuV3x25519WithXc20PkwV2 | xc20pAuthEncrypterEcdh1PuV3x25519WithXc20PkwV2() } instead\n */\nexport function createAuthEncrypter(\n  recipientPublicKey: Uint8Array,\n  senderSecret: Uint8Array | ECDH,\n  options: Partial<AuthEncryptParams> = {}\n): Encrypter {\n  return xc20pAuthEncrypterEcdh1PuV3x25519WithXc20PkwV2(recipientPublicKey, senderSecret, options)\n}\n\n/**\n * @deprecated Use {@link xc20pAnonEncrypterEcdhESx25519WithXc20PkwV2 | xc20pAnonEncrypterEcdhESx25519WithXc20PkwV2() }\n *   instead\n */\nexport function createAnonEncrypter(publicKey: Uint8Array, options: Partial<AnonEncryptParams> = {}): Encrypter {\n  return xc20pAnonEncrypterEcdhESx25519WithXc20PkwV2(publicKey, options)\n}\n\n/**\n * @deprecated Use\n *   {@link xc20pAuthDecrypterEcdh1PuV3x25519WithXc20PkwV2 | xc20pAuthDecrypterEcdh1PuV3x25519WithXc20PkwV2() } instead\n */\nexport function createAuthDecrypter(recipientSecret: Uint8Array | ECDH, senderPublicKey: Uint8Array): Decrypter {\n  return xc20pAuthDecrypterEcdh1PuV3x25519WithXc20PkwV2(recipientSecret, senderPublicKey)\n}\n\n/**\n * @deprecated Use {@link xc20pAnonDecrypterEcdhESx25519WithXc20PkwV2 | xc20pAnonDecrypterEcdhESx25519WithXc20PkwV2() }\n *   instead\n */\nexport function createAnonDecrypter(recipientSecret: Uint8Array | ECDH): Decrypter {\n  return xc20pAnonDecrypterEcdhESx25519WithXc20PkwV2(recipientSecret)\n}\n\nexport function validateHeader(header?: ProtectedHeader): Required<Pick<ProtectedHeader, 'epk' | 'iv' | 'tag'>> {\n  if (!(header && header.epk && header.iv && header.tag)) {\n    throw new Error('bad_jwe: malformed header')\n  }\n  return header as Required<Pick<ProtectedHeader, 'epk' | 'iv' | 'tag'>>\n}\n\nexport const xc20pKeyWrapper: KeyWrapper = {\n  from: (wrappingKey: Uint8Array) => {\n    const wrap = async (cek: Uint8Array): Promise<WrappingResult> => {\n      return xc20pEncrypter(wrappingKey)(cek)\n    }\n    return { wrap }\n  },\n\n  alg: 'XC20PKW',\n}\n\n/**\n * @deprecated Use {@link xc20pAnonEncrypterEcdhESx25519WithXc20PkwV2 | xc20pAnonEncrypterEcdhESx25519WithXc20PkwV2() }\n *   instead\n */\nexport function x25519Encrypter(publicKey: Uint8Array, kid?: string, apv?: string): Encrypter {\n  return xc20pAnonEncrypterEcdhESx25519WithXc20PkwV2(publicKey, { kid, apv })\n}\n\n/**\n * Recommended encrypter for anonymous encryption (i.e. no sender authentication).\n * Uses {@link https://tools.ietf.org/html/draft-amringer-jose-chacha-02 | ECDH-ES+XC20PKW v2}.\n *\n * @param recipientPublicKey - the byte array representing the recipient public key\n * @param options - {@link AnonEncryptParams} used to specify the recipient key ID (`kid`)\n *\n * @returns an {@link Encrypter} instance usable with {@link createJWE}\n *\n * NOTE: ECDH-ES+XC20PKW is a proposed draft in IETF and not a standard yet and\n * is subject to change as new revisions or until the official CFRG specification is released.\n */\nexport function xc20pAnonEncrypterEcdhESx25519WithXc20PkwV2(\n  recipientPublicKey: Uint8Array,\n  options: Partial<AnonEncryptParams> = {}\n): Encrypter {\n  return createFullEncrypter(\n    recipientPublicKey,\n    undefined,\n    options,\n    { createKek: createX25519EcdhEsKek, alg: 'ECDH-ES' },\n    xc20pKeyWrapper,\n    { from: (cek: Uint8Array) => xc20pDirEncrypter(cek), enc: 'XC20P' }\n  )\n}\n\n/**\n *  Recommended encrypter for authenticated encryption (i.e. sender authentication and requires\n *  sender private key to encrypt the data).\n *  Uses {@link https://tools.ietf.org/html/draft-madden-jose-ecdh-1pu-03 | ECDH-1PU v3 } and\n *  {@link https://tools.ietf.org/html/draft-amringer-jose-chacha-02 | XC20PKW v2 }.\n *\n *  @param recipientPublicKey - the byte array representing the recipient public key\n *  @param senderSecret - either a Uint8Array representing the sender secret key or\n *    an ECDH function that wraps the key and can promise a shared secret given a public key\n *  @param options - {@link AuthEncryptParams} used to specify extra header parameters\n *\n *  @returns an {@link Encrypter} instance usable with {@link createJWE}\n *\n *  NOTE: ECDH-1PU and XC20PKW are proposed drafts in IETF and not a standard yet and\n *  are subject to change as new revisions or until the official CFRG specification are released.\n *\n * Implements ECDH-1PU+XC20PKW with XChaCha20Poly1305 based on the following specs:\n *   - {@link https://tools.ietf.org/html/draft-amringer-jose-chacha-02 | XC20PKW}\n *   - {@link https://tools.ietf.org/html/draft-madden-jose-ecdh-1pu-03 | ECDH-1PU}\n */\nexport function xc20pAuthEncrypterEcdh1PuV3x25519WithXc20PkwV2(\n  recipientPublicKey: Uint8Array,\n  senderSecret: Uint8Array | ECDH,\n  options: Partial<AuthEncryptParams> = {}\n): Encrypter {\n  return createFullEncrypter(\n    recipientPublicKey,\n    senderSecret,\n    options,\n    { createKek: createX25519Ecdh1PUv3Kek, alg: 'ECDH-1PU' },\n    xc20pKeyWrapper,\n    { from: (cek: Uint8Array) => xc20pDirEncrypter(cek), enc: 'XC20P' }\n  )\n}\n\nexport async function resolveX25519Encrypters(dids: string[], resolver: Resolvable): Promise<Encrypter[]> {\n  const encryptersForDID = async (did: string, resolved: string[] = []): Promise<Encrypter[]> => {\n    const { didResolutionMetadata, didDocument } = await resolver.resolve(did)\n    resolved.push(did)\n    if (didResolutionMetadata?.error || didDocument == null) {\n      throw new Error(\n        `resolver_error: Could not resolve ${did}: ${didResolutionMetadata.error}, ${didResolutionMetadata.message}`\n      )\n    }\n    let controllerEncrypters: Encrypter[] = []\n    if (!didDocument.controller && !didDocument.keyAgreement) {\n      throw new Error(`no_suitable_keys: Could not find x25519 key for ${did}`)\n    }\n    if (didDocument.controller) {\n      let controllers = Array.isArray(didDocument.controller) ? didDocument.controller : [didDocument.controller]\n      controllers = controllers.filter((c) => !resolved.includes(c))\n      const encrypterPromises = controllers.map((did) =>\n        encryptersForDID(did, resolved).catch(() => {\n          return []\n        })\n      )\n      const encrypterArrays = await Promise.all(encrypterPromises)\n      controllerEncrypters = ([] as Encrypter[]).concat(...encrypterArrays)\n    }\n    const agreementKeys: VerificationMethod[] = didDocument.keyAgreement\n      ?.map((key) => {\n        if (typeof key === 'string') {\n          return [...(didDocument.publicKey || []), ...(didDocument.verificationMethod || [])].find(\n            (pk) => pk.id === key\n          )\n        }\n        return key\n      })\n      ?.filter((key) => typeof key !== 'undefined') as VerificationMethod[]\n    const pks =\n      agreementKeys?.filter((key) =>\n        ['X25519KeyAgreementKey2019', 'X25519KeyAgreementKey2020', 'JsonWebKey2020', 'Multikey'].includes(key.type)\n      ) ?? []\n    if (!pks.length && !controllerEncrypters.length)\n      throw new Error(`no_suitable_keys: Could not find X25519 key for ${did}`)\n    return pks\n      .map((pk) => {\n        const { keyBytes, keyType } = extractPublicKeyBytes(pk)\n        if (keyType === 'X25519') {\n          return x25519Encrypter(keyBytes, pk.id)\n        } else {\n          return null\n        }\n      })\n      .filter(isDefined)\n      .concat(...controllerEncrypters)\n  }\n\n  const encrypterPromises = dids.map((did) => encryptersForDID(did))\n  const encrypterArrays = await Promise.all(encrypterPromises)\n  return ([] as Encrypter[]).concat(...encrypterArrays)\n}\n\n/**\n * @deprecated Use {@link xc20pAnonDecrypterEcdhESx25519WithXc20PkwV2 | xc20pAnonDecrypterEcdhESx25519WithXc20PkwV2() }\n *   instead\n */\nexport function x25519Decrypter(receiverSecret: Uint8Array | ECDH): Decrypter {\n  return xc20pAnonDecrypterEcdhESx25519WithXc20PkwV2(receiverSecret)\n}\n\n/**\n * Recommended decrypter for anonymous encryption (i.e. no sender authentication).\n * Uses {@link https://tools.ietf.org/html/draft-amringer-jose-chacha-02 | ECDH-ES+XC20PKW v2 }.\n *\n * @param recipientSecret - either a Uint8Array representing the recipient secret key or\n *   an ECDH function that wraps the key and can promise a shared secret given a public key\n *\n * @returns a {@link Decrypter} instance usable with {@link decryptJWE}\n *\n * NOTE: ECDH-ES+XC20PKW is a proposed draft in IETF and not a standard yet and\n * is subject to change as new revisions or until the official CFRG specification is released.\n *\n * @beta\n */\nexport function xc20pAnonDecrypterEcdhESx25519WithXc20PkwV2(recipientSecret: Uint8Array | ECDH): Decrypter {\n  const alg = 'ECDH-ES+XC20PKW'\n  const enc = 'XC20P'\n\n  async function decrypt(\n    sealed: Uint8Array,\n    iv: Uint8Array,\n    aad?: Uint8Array,\n    recipient?: Recipient\n  ): Promise<Uint8Array | null> {\n    recipient = <Recipient>recipient\n    const header = validateHeader(recipient.header)\n\n    const kek = await computeX25519EcdhEsKek(recipient, recipientSecret, alg)\n    if (!kek) return null\n    // Content Encryption Key\n    const sealedCek = toSealed(recipient.encrypted_key, header.tag)\n    const cek = await xc20pDirDecrypter(kek).decrypt(sealedCek, base64ToBytes(header.iv))\n    if (cek === null) return null\n\n    return xc20pDirDecrypter(cek).decrypt(sealed, iv, aad)\n  }\n\n  return { alg, enc, decrypt }\n}\n\n/**\n * Recommended decrypter for authenticated encryption (i.e. sender authentication and requires\n * sender public key to decrypt the data).\n * Uses {@link https://tools.ietf.org/html/draft-madden-jose-ecdh-1pu-03 | ECDH-1PU v3 } and\n * {@link https://tools.ietf.org/html/draft-amringer-jose-chacha-02 | XC20PKW v2 }.\n *\n * @param recipientSecret - either a Uint8Array representing the recipient secret key or\n *   an ECDH function that wraps the key and can promise a shared secret given a public key\n * @param senderPublicKey - the byte array representing the sender public key\n *\n * @returns a {@link Decrypter} instance usable with {@link decryptJWE}\n *\n * NOTE: ECDH-1PU and XC20PKW are proposed drafts in IETF and not a standard yet and\n * are subject to change as new revisions or until the official CFRG specification are released.\n *\n * @beta\n *\n * Implements ECDH-1PU+XC20PKW with XChaCha20Poly1305 based on the following specs:\n *   - {@link https://tools.ietf.org/html/draft-amringer-jose-chacha-02 | XC20PKW}\n *   - {@link https://tools.ietf.org/html/draft-madden-jose-ecdh-1pu-03 | ECDH-1PU}\n */\nexport function xc20pAuthDecrypterEcdh1PuV3x25519WithXc20PkwV2(\n  recipientSecret: Uint8Array | ECDH,\n  senderPublicKey: Uint8Array\n): Decrypter {\n  const alg = 'ECDH-1PU+XC20PKW'\n  const enc = 'XC20P'\n\n  async function decrypt(\n    sealed: Uint8Array,\n    iv: Uint8Array,\n    aad?: Uint8Array,\n    recipient?: Recipient\n  ): Promise<Uint8Array | null> {\n    recipient = <Recipient>recipient\n    const header = validateHeader(recipient.header)\n    const kek = await computeX25519Ecdh1PUv3Kek(recipient, recipientSecret, senderPublicKey, alg)\n    if (!kek) return null\n    // Content Encryption Key\n    const sealedCek = toSealed(recipient.encrypted_key, header.tag)\n    const cek = await xc20pDirDecrypter(kek).decrypt(sealedCek, base64ToBytes(header.iv))\n    if (cek === null) return null\n\n    return xc20pDirDecrypter(cek).decrypt(sealed, iv, aad)\n  }\n\n  return { alg, enc, decrypt }\n}\n"],"names":["u8a","toString","fromString","concat","bytesToBase64url","b","base64ToBytes","s","inputBase64Url","replace","base58ToBytes","bytesToBase58","SUPPORTED_PUBLIC_KEY_TYPES","ES256","ES256K","Ed25519","EdDSA","VM_TO_KEY_TYPE","Secp256k1SignatureVerificationKey2018","Secp256k1VerificationKey2018","EcdsaSecp256k1VerificationKey2019","EcdsaPublicKeySecp256k1","EcdsaSecp256k1RecoveryMethod2020","EcdsaSecp256r1VerificationKey2019","Ed25519VerificationKey2018","Ed25519VerificationKey2020","ED25519SignatureVerification","X25519KeyAgreementKey2019","X25519KeyAgreementKey2020","ConditionalProof2022","undefined","JsonWebKey2020","Multikey","supportedCodecs","CODEC_TO_KEY_TYPE","extractPublicKeyBytes","pk","publicKeyBase58","keyBytes","keyType","type","publicKeyBase64","publicKeyHex","hexToBytes","publicKeyJwk","crv","x","y","secp256k1","ProjectivePoint","fromAffine","bytesToBigInt","toRawBytes","p256","kty","includes","publicKeyMultibase","multibaseToBytes","Uint8Array","bytesToMultibase","base","codec","encode","codecCode","prefixLength","varint","encodingLength","multicodecEncoding","length","encodeTo","set","bytes","decode","possibleCodec","Object","entries","filter","code","slice","e","minLength","input","startsWith","substring","paddedLength","Math","max","padStart","toLowerCase","encodeBase64url","decodeBase64url","bytesToHex","BigInt","stringToBytes","toJose","r","recoveryParam","recoverable","jose","Error","fromJose","signature","signatureBytes","TypeError","toSealed","ciphertext","tag","leftpad","data","size","repeat","generateKeyPair","secretKey","x25519","utils","randomPrivateKey","publicKey","getPublicKey","generateKeyPairFromSeed","seed","genX25519EphemeralKeyPair","epk","publicKeyJWK","isDefined","arg","sha256","payload","sha256Hash","keccak","keccak_256","toEthereumAddress","hexPublicKey","hashInput","writeUint32BE","value","array","encoded","lengthAndInput","concatKDF","secret","keyLen","alg","producerInfo","consumerInfo","roundNumber","ES256KSigner","privateKey","privateKeyBytes","sign","recovery","SimpleSigner","hexPrivateKey","signer","EllipticSigner","EdDSASigner","dataBytes","ed25519","NaclSigner","base64PrivateKey","ES256Signer","ES256HSMSigner","pufHsmRemoteUrl","fetch","method","headers","body","JSON","stringify","content","response","ok","status","text","parse","error","console","instanceOfEcdsaSignature","object","ES256SignerAlg","ES256KSignerAlg","Ed25519SignerAlg","algorithms","SignerAlg","impl","publicKeyToAddress","otherAddress","version","publicKeyBuffer","publicKeyHash","ripemd160","step1","step2","step3","checksum","step4","prefix","fromHex","hash","words","bech32","toWords","verifyBlockchainAccountId","blockchainAccountId","chain","split","bip122","cosmos","join","toSignatureObject","rawSig","sigObj","toSignatureObject2","compact","verifyES256","authenticators","signatures","push","so","checkSignatureAgainstSigner","Signature","fromCompact","addRecoveryBit","recoveredPublicKey","recoverPublicKey","recoveredAddress","toHex","recoveredPublicKeyHex","recoveredCompressedPublicKeyHex","find","a","keyHex","ethereumAddress","verificationMethod","verifyES256K","signatureNormalized","normalizeS","fullPublicKeys","blockchainAddressKeys","verify","err","verifyRecoverableES256K","verifyEd25519","clear","VerifierAlgorithm","JWT_ERROR","INVALID_JWT","INVALID_AUDIENCE","INVALID_SIGNATURE","NO_SUITABLE_KEYS","NOT_SUPPORTED","RESOLVER_ERROR","verifyConditionDelegated","jwt","header","authenticator","options","conditionDelegated","resolver","foundSigner","issuer","resolveAuthenticator","proofPurpose","didAuthenticator","id","didResolutionResult","didDocument","delegatedAuthenticator","CONDITIONAL_PROOF_2022","verifyJWT","verified","verifyJWTDecoded","message","then","observer","pact","prototype","onFulfilled","result","state","callback","_settle","verifyConditionWeightedThreshold","conditionWeightedThreshold","threshold","issuers","weightCount","weightedCondition","weight","currentCondition","condition","newOptions","verifyConditionalProof","verifyProof","v","onRejected","i","reject","update","bind","_resumeAfterUpdate","types","didResult","resolve","accept","DID_JSON","getOwnPropertyNames","indexOf","didDocumentMetadata","didResolutionMetadata","contentType","getPublicKeyById","verificationMethods","pubid","filtered","publicKeysToCheck","assertionMethod","map","key","supported","auth","audience","callbackUrl","skewTime","policies","now","floor","Date","NBF_SKEW","nowSkewed","nbf","iat","exp","aud","audArray","Array","isArray","matchedAudience","item","did","didUrl","decodeJWT","hasOwnProperty","call","iss","client_id","SELF_ISSUED_V2","SELF_ISSUED_V2_VC_INTEROP","sub","sub_jwk","kid","SELF_ISSUED_V0_1","scope","redirect_uri","createMultisignatureJWT","expiresIn","canonicalize","payloadResult","typ","cty","createJWT","timestamps","fullPayload","createJWS","defaultAlg","encodedPayload","encodeSection","signingInput","jwtSigner","shouldCanonicalize","canonicalizeData","decodeJWS","jws","parts","match","recurse","decodedJwt","assign","innerDecodedJwt","pubKeys","verifyJWSDecoded","verifyJWS","jwsDecoded","_this","thenable","validateJWE","jwe","protected","iv","recipients","rec","encrypted_key","encodeJWE","protectedHeader","recipient","aad","decryptJWE","decrypter","cleartext","protHeader","enc","sealed","decrypt","createJWE","encrypters","useSingleEphemeralKey","encrypt","encryptionResult","tmpEnc","reduce","acc","encrypter","cek","genEpk","encryptCek","xc20pEncrypter","randomBytes","cipher","xchacha20poly1305","subarray","xc20pDirEncrypter","encodedAad","xc20pEncrypt","xc20pDirDecrypter","createX25519EcdhEsKek","recipientPublicKey","senderSecret","apu","apv","ephemeralKeyPair","ephemeral","sharedSecret","getSharedSecret","kek","computeX25519EcdhEsKek","receiverSecret","createX25519Ecdh1PUv3Kek","zE","zS","partyUInfo","partyVInfo","computeX25519Ecdh1PUv3Kek","recipientSecret","senderPublicKey","createX25519ECDH","mySecretKey","theirPublicKey","createFullEncrypter","kekCreator","keyWrapper","contentEncrypter","from","createKek","wrap","res","resolveX25519Encrypters","dids","encryptersForDID","resolved","agreementKeys","keyAgreement","pks","controllerEncrypters","x25519Encrypter","controller","controllers","c","encrypterPromises","catch","Promise","all","encrypterArrays","createAuthEncrypter","xc20pAuthEncrypterEcdh1PuV3x25519WithXc20PkwV2","createAnonEncrypter","xc20pAnonEncrypterEcdhESx25519WithXc20PkwV2","createAuthDecrypter","xc20pAuthDecrypterEcdh1PuV3x25519WithXc20PkwV2","createAnonDecrypter","xc20pAnonDecrypterEcdhESx25519WithXc20PkwV2","validateHeader","xc20pKeyWrapper","wrappingKey","x25519Decrypter","sealedCek"],"mappings":"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"}